\documentclass{article}

\usepackage{arxiv}
\usepackage{bussproofs}
\usepackage{amsmath}
\usepackage{color}
\usepackage{listings}

\definecolor{dkgreen}{rgb}{0,0.6,0}
\definecolor{gray}{rgb}{0.5,0.5,0.5}
\definecolor{mauve}{rgb}{0.58,0,0.82}

\lstset{frame=tb,
  language=Haskell,
  aboveskip=3mm,
  belowskip=3mm,
  showstringspaces=false,
  columns=flexible,
  basicstyle={\small\ttfamily},
  numbers=none,
  numberstyle=\tiny\color{gray},
  keywordstyle=\color{blue},
  commentstyle=\color{dkgreen},
  stringstyle=\color{mauve},
  breaklines=true,
  breakatwhitespace=true,
  frame=none,
  tabsize=3
}

\title{Tutorial on implementing Hoare logic for imperative programs in Haskell}

\author{
  Boro Sitnikovski \\
  Skopje, North Macedonia \\
  \texttt{buritomath@gmail.com} \\
}

\begin{document}
\maketitle

\begin{abstract}
Using the programming language Haskell, we introduce an implementation of propositional calculus, number theory, and then of a simple imperative language that can evaluate arithmetic and logical expressions. As we expand the language, we will show several evaluation strategies, considering the normalization property and how it affects an implementation. Finally, we will provide a bottom-up implementation of Hoare's logic which will allow us to deduce facts about programs without the need for a full evaluation.
\end{abstract}

\keywords{Imperative languages \and Functional languages \and Number Theory \and Peano axioms \and Hoare logic \and Formal verification \and Haskell}

\section{Introduction}

Nowadays, imperative programming languages run the world, to list a few popular ones: C, Python, JavaScript, PHP. Code is usually written in these languages by using an imperative style; that is, the computer is being told ("commanded") what to do and how to do it specifically. The mathematical language is very unlike this, it is more declarative rather than imperative, that is, it doesn't care about the how.

Since a programmer has to specify the exact "how", it is easy to make a programming error. In addition, given the popularity of these programming languages, there are many bugs in software applications that are programmed in them. This motivates for a way to formally verify certain properties about programs written in these languages. Hoare logic is one way to mechanically reason about computer programs.

We will provide an implementation of an imperative language, together with a toy implementation a number theoretical system. Finally, we will provide an implementation of Hoare logic based on the previous systems, that will allow us to reason about programs in this language. Our implementation of Hoare's logic will be bottom-up, in the sense that we will build the proofs from the ground up, in contrast to e.g. programming languages such as Dafny\cite{b1}, that build proofs from top to bottom. That is, in Dafny, the user provides a proposition and Dafny will derive the proof, automatically, using the automated theorem prover Z3\cite{b2}.

The programming language that we will implement already has an implementation in Coq\cite{b3}. However, implementing a language in Haskell is more concerned about playing at the value level (and to some extent at the type level), whereas in a dependently-typed language the focus is at the type level. Specifically for Hoare's logic, in Haskell we cannot use any of the meta language's constructs to do mathematical proofs, so we have to take care of these algorithms ourselves.

Haskell is not a strongly normalizing language, which means that not every evaluation necessarily terminates. However, in dependently-typed languages, such as Coq\cite{b4}, the evaluation of proof terms (e.g. the type checker) is strongly normalizing, and this is what allows us to express mathematical proofs.

There are good introductory books on dependent types\cite{b3}. In some books, there is a gentler approach that might be handy for newcomers\cite{b5}. There are good introductions to Haskell as well\cite{b6}.

\section{Propositional calculus}

In this section we will provide an implementation of Propositional calculus, as described in GEB\cite{b7}.

\subsection{Syntax}

The syntax of the formal system expressed in BNF is:

\begin{lstlisting}
prop   ::= bterm | bterm brelop bterm | aterm arelop aterm | unop bterm
bterm  ::= P | Q | R
unop   ::= "!"
brelop ::= "&&" | "||" | "->"
\end{lstlisting}

The same syntax can be represented with the following Haskell code:

\begin{lstlisting}
data PropCalc =
  P | Q | R
  | Not PropCalc
  | And PropCalc PropCalc
  | Or PropCalc PropCalc
  | Imp PropCalc PropCalc
\end{lstlisting}

We will slightly rewrite this to make it more generic, so that instead of passing specific variables, we'll just use polymorphic types. This will allow us to later embed this system easily in other systems.

\begin{lstlisting}
data PropCalc a =
  PropVar a
  | Not (PropCalc a)
  | And (PropCalc a) (PropCalc a)
  | Or (PropCalc a) (PropCalc a)
  | Imp (PropCalc a) (PropCalc a)
\end{lstlisting}

With this datatype, we have a way to represent some logical formulas, e.g. $A \land B$:

\begin{lstlisting}
> And (PropVar A) (PropVar B)
<A> /\ <B>
\end{lstlisting}

We will also need a way to differentiate between well-formed formulas and theorems, since not all well-formed formulas are theorems. For that, we provide the \texttt{Proof} data type constructor:

\begin{lstlisting}
newtype Proof a = Proof a deriving (Eq)

instance (Show a) => Show (Proof a) where
  show (Proof a) = "|- " ++ show a

fromProof :: Proof a -> a
fromProof (Proof a) = a
\end{lstlisting}

Note that \texttt{Proof \$ And (PropVar A) (PropVar B)} is different from \texttt{And (PropVar A) (PropVar B)}. However, this constructor must not be used directly; proofs should only be constructed given the rules, which we provide next.

\subsection{Rules}

These formation rules come from GEB, and we list them here for posterity:

\begin{itemize}
\item \textbf{Carry Over Rule}: Inside a fantasy, any theorem from the "reality" one level higher can be brought in and used.
\item \textbf{Contrapositive Rule}: $< x \to y>$ and $< \neg y \to \neg x>$ are interchangeable.
\item \textbf{De Morgan's Rule}: $< \neg x \land \neg y>$ and $\neg<x \lor y>$ are interchangeable.
\item \textbf{Double-Tilde Rule}: The string $\neg\neg$ can be deleted from any theorem. It can also be inserted into any theorem, provided that the resulting string is itself well-formed
\item \textbf{Fantasy Rule}: If $x$ were a theorem, $y$ would be a theorem ($<x \to y>$).
\item \textbf{Joining Rule}: If $x$ and $y$ are theorems, then $<x \land y>$ is a theorem.
\item \textbf{Rule of Detachment}: If $x$ and $<x \to y>$ are both theorems, then $y$ is a theorem.
\item \textbf{Sep Rule}: If $<x \land y>$ is a theorem, then both $x$ and $y$ are theorems.
\item \textbf{Switcheroo Rule}: $<x \lor y>$ and $<\neg x \to y>$ are interchangeable.
\end{itemize}

For example, here's how we can implement \textbf{Sep Rule} and \textbf{Joining Rule} in Haskell:

\begin{lstlisting}
ruleJoin :: Proof (PropCalc a) -> Proof (PropCalc a) -> Proof (PropCalc a)
ruleJoin (Proof x) (Proof y) = Proof $ And x y

ruleSepL :: Proof (PropCalc a) -> Proof (PropCalc a)
ruleSepL (Proof (And x y)) = Proof x
ruleSepL x = x

ruleSepR :: Proof (PropCalc a) -> Proof (PropCalc a)
ruleSepR (Proof (And x y)) = Proof y
ruleSepR x = x
\end{lstlisting}

That is, we just lift the values from the object level to Haskell's level, and Haskell's neat type system takes care of everything else.

Perhaps the most powerful rule is the implication-intro (fantasy), and its counter-part implication-elim (detachment). Here's their implementation:

\begin{lstlisting}
ruleFantasy :: (Proof (PropCalc a) -> Proof (PropCalc a)) -> PropCalc a -> Proof (PropCalc a)
ruleFantasy f x = Proof $ Imp x $ fromProof (f (Proof x))

ruleDetachment :: Eq a => Proof (PropCalc a) -> Proof (PropCalc a) -> Either String (Proof (PropCalc a))
ruleDetachment (Proof x) (Proof (Imp x' y)) | x == x' = Right $ Proof y
ruleDetachment _ _ = Left "ruleDetachment: Cannot construct proof"
\end{lstlisting}

Note how we accept a non-proven term within \texttt{ruleFantasy}, whereas in other rules we accept proven terms. That is because the hypothesis needn't be necessarily true, since it just states that "In the case this hypothesis is true, that is true".

For the other rule, we use \texttt{Either} to distinguish between provable and unprovable terms. In addition, we rely on Haskell's machinery for functions (lambda calculus) to take care of doing the actual work. Now we can prove neat stuff, such as $P \land Q \to Q \land P$:

\begin{lstlisting}
> ruleFantasy (\pq -> ruleJoin (ruleSepR pq) (ruleSepL pq)) (And (PropVar P) (PropVar Q))
|- <<P> /\ <Q>> -> <<Q> /\ <P>>
\end{lstlisting}

Here's another example implementation for the \textbf{Double-Tilde Rule}:

\begin{lstlisting}
ruleDoubleTildeIntro :: Proof (PropCalc a) -> Proof (PropCalc a)
ruleDoubleTildeIntro (Proof x) = Proof $ Not (Not x)

ruleDoubleTildeElim :: Proof (PropCalc a) -> Proof (PropCalc a)
ruleDoubleTildeElim (Proof (Not (Not x))) = Proof x
ruleDoubleTildeElim x = x
\end{lstlisting}

However, how do we apply this rule to $R$ within $P \land (Q \lor R)$? Our current implementation doesn't allow for that, because it only accepts a full formula and doesn't know how to do replacements in its subformulas.

To address this, we create a function that will accept a "path" (which subformula we apply it to), what rule should be applied, and the formula itself.

\begin{lstlisting}
data Pos = GoLeft | GoRight

type Path = [Pos]

applyPropRule :: Path -> (Proof (PropCalc a) -> Proof (PropCalc a)) -> Proof (PropCalc a) -> Proof (PropCalc a)
applyPropRule xs f (Proof x) = Proof $ go xs (\x -> fromProof $ f (Proof x)) x
  where
  go :: Path -> (PropCalc a -> PropCalc a) -> PropCalc a -> PropCalc a
  go (GoLeft:xs) f (Not x) = Not (go xs f x)
  go (GoLeft:xs) f (And x y) = And (go xs f x) y
  go (GoLeft:xs) f (Or x y) = Or (go xs f x) y
  go (GoLeft:xs) f (Imp x y) = Imp (go xs f x) y
  go (GoRight:xs) f (Not x) = Not (go xs f x)
  go (GoRight:xs) f (And x y) = And x (go xs f y)
  go (GoRight:xs) f (Or x y) = Or x (go xs f y)
  go (GoRight:xs) f (Imp x y) = Imp x (go xs f y)
  go _ f x = f x
\end{lstlisting}

Of course, going left or right doesn't make much sense for unary operators, so our implementation will just drill down in the \texttt{Not} operator if it finds either a left or a right. But, left and right do make sense for binary operators - we drill on the left and the right argument respectively.

Now we can use it to apply the double negation rule to $R$ within $P \land (Q \lor R)$ as follows:

\begin{lstlisting}
> ruleFantasy (applyPropRule [GoRight, GoRight] ruleDoubleTildeIntro) (And (PropVar P) (Or (PropVar Q) (PropVar R)))
|- <<P> /\ <<Q> \/ <R>>> -> <<P> /\ <<Q> \/ <~~R>>>
\end{lstlisting}

\section{Number theory}

In this section, we will proivde an implementation of a simple number theoretical system, using the same literature (GEB).

\subsection{Syntax}

We start by introducing a language that can represent arithmetical expressions. The syntax of the language expressed in BNF (Backus-Naur Form) is as follows:

\begin{lstlisting}
digit  ::= "0" | "1" | ... | "8" | "9"
arith  ::= aterm | aterm relop aterm
number ::= - digit* | digit*
relop  ::= "+" | "*"
aterm  ::= arith | number | var
var    ::= A | B | C ... | Y | Z
\end{lstlisting}

Followed by a direct translation to Haskell code:

\begin{lstlisting}
data Arith =
  Num Integer
  | Var Char
  | Plus Arith Arith
  | Mult Arith Arith
\end{lstlisting}

As we did with \texttt{PropCalc} earlier, we will slightly rewrite this in a more generic fashion; getting rid off integers (implement our own zero and successor), and abstracting \texttt{Char}:

\begin{lstlisting}
data Arith a =
  Var a
  | Z
  | S (Arith a)
  | Plus (Arith a) (Arith a)
  | Mult (Arith a) (Arith a)
\end{lstlisting}

Now we can represent things like $0 + 1*A$ as follows:

\begin{lstlisting}
> Plus Z (Mult (S Z) (Var A))
(0)+((S(0))*(A))
\end{lstlisting}

The next step is to implement the components from first-order logic (quantifiers and arithmetical equations). Here's the 

\begin{lstlisting}
fol    ::= eq arith arith | forall var prop | exists a prop
var    ::= A | B | C ... | Y | Z
\end{lstlisting}

Note how we just embedded \texttt{PropCalc} within the system's syntax. Here's the same represented with Haskell code:

\begin{lstlisting}
data FOL a =
  Eq (Arith a) (Arith a)
  | ForAll a (PropCalc (FOL a))
  | Exists a (PropCalc (FOL a))
\end{lstlisting}

Similarly as before, this constructor must not be used directly; proofs should only be constructed given the rules, which we provide next.

\subsection{Rules}

Again, these formation rules come from GEB, and we list them here for posterity:

\begin{itemize}
\item \textbf{Rule of Specification}: Suppose $u$ is a variable which occurs inside the string $x$. If the string $\forall u:x$ is a theorem, then so is $x$, and so are any strings made from $x$ by replacing $u$, wherever it occurs, by one and the same term. (Restriction: The term which replaces $u$ must not contain any variable that is quantified in $x$.)
\item \textbf{Rule of Generalization}: Suppose $x$ is a theorem in which $u$, a variable, occurs free. Then $\forall u:x$ is a theorem. (Restriction: No generalization is allowed in a fantasy on any variable which appeared free in the fantasy's premise.)
\item \textbf{Rule of Interchange}: Suppose $u$ is a variable. Then the strings $\forall u:\neg$ and $\neg \exists u:$ are interchangeable anywhere inside any theorem.
\item \textbf{Rule of Existence}: Suppose a term (which may contain variables as long as they are free) appears once, or multiply, in a theorem. Then any (or several, or all) of the appearances of the term may be replaced by a variable which otherwise does not occur in the theorem, and the corresponding existential quantifier must be placed in front.
\item \textbf{Rule of Symmetry}: If $r=s$ is a theorem, then so is $s=r$
\item \textbf{Rule of Transitivity}: If $r=s$ and $s=t$ are theorems, then so is $r=t$
\item \textbf{Rule Add S}: If $r=t$ is a theorem, then $Sr=St$ is a theorem.
\item \textbf{Rule Drop S}: If $Sr=St$ is theorem, then $r=t$ is a theorem.
\item \textbf{Rule of Induction}: Let $X[u]$ represent a well-formed formula in which the variable $u$ is free, and $X[x/u]$ represent the same string, with each appearance of $u$ replaced by $x$. If both $\forall u:X[u] \to X[Su/u]$ and $X[0/u]$ are theorems, then $\forall u:X[u]$ is also a theorem.
\end{itemize}

We provide an implementation of \texttt{substPropCalc}, which replaces all occurences of a term with another term in a formula:

\begin{lstlisting}
substPropCalc :: Eq a => Proof (PropCalc (FOL a)) -> Arith a -> Arith a -> Proof (PropCalc (FOL a))
substPropCalc (Proof f) v e = Proof $ go f v e
  where
  go :: Eq a => PropCalc (FOL a) -> Arith a -> Arith a -> PropCalc (FOL a)
  go (PropVar (Eq a b)) v e     = PropVar (Eq (substArith a v e) (substArith b v e))
  go (PropVar (ForAll x y)) v e = PropVar (ForAll x (go y v e))
  go (PropVar (Exists x y)) v e = PropVar (Exists x (go y v e))
  go (Not x) v e                = Not (go x v e)
  go (And x y) v e              = And (go x v e) (go y v e)
  go (Or x y) v e               = Or (go x v e) (go y v e)
  go (Imp x y) v e              = Imp (go x v e) (go y v e)
\end{lstlisting}

The function \texttt{substArith} is similar to \texttt{substPropCalc}, but it's defined for its own data type.

Next, given the functions \texttt{getArithVars} and \texttt{getBoundVars} to retrieve all variables in an arithmetic expression and all bound variables in a formula respectively, we provide an an example implementation of \textbf{Rule of Specification}:

\begin{lstlisting}
ruleSpec :: Eq a => Proof (PropCalc (FOL a)) -> a -> Arith a -> Proof (PropCalc (FOL a))
ruleSpec (Proof f) v e = Proof $ go f v e
  where
  go :: Eq a => PropCalc (FOL a) -> a -> Arith a -> PropCalc (FOL a)
  go (PropVar (ForAll x y)) v e | x == v && not (any (`elem` getArithVars e) (getBoundVars y)) = fromProof $ substPropCalc (Proof y) (Var x) e
  go x _ _ = x
\end{lstlisting}

We can also implement the \textbf{Rule of Generalization} as follows:

\begin{lstlisting}
ruleGeneralize :: Eq a => Proof (PropCalc (FOL a)) -> a -> Maybe (Proof (PropCalc (FOL a))) -> Proof (PropCalc (FOL a))
ruleGeneralize (Proof f) v Nothing | v `notElem` getBoundVars f
  = Proof $ PropVar (ForAll v f)
ruleGeneralize (Proof f) v (Just premise) | v `notElem` getBoundVars f && v `notElem` getFreeVars (fromProof premise) -- fantasy vars
  = Proof $ PropVar (ForAll v f)
ruleGeneralize x _ _ = x
\end{lstlisting}

Another interesting rule is the existence one; we can't simply substitute everything like we did within \texttt{ruleSpec}; we need to allow for one, or multiple terms replacement.

We're given the following:

\begin{itemize}
\item \texttt{applyFOLRule} and \texttt{applyArithRule}, both of which are similar to \texttt{applyPropRule}.
\item \texttt{applyFOLArithRule} which is a combination of \texttt{applyFOLRule} and \texttt{applyArithRule}, which takes a list of paths and then applies the rule to all of them.
\item \texttt{getTerms} which given a list of paths, returns list of terms - we check that each term is equivalent to others before applying the rule.
\end{itemize}

Now, the \textbf{Rule of Existence} can be easily implemented:

\begin{lstlisting}
ruleExistence :: Eq a => Proof (PropCalc (FOL a)) -> a -> [(Pos, Path, Path)] -> Proof (PropCalc (FOL a))
ruleExistence f v paths | allSame (getTerms paths f) = Proof $ PropVar (Exists v (fromProof (go f paths)))
  where
  go f ((pos, path1, path2):paths) =
    let newProof = applyFOLArithRule pos path1 path2 (\_ -> Var v) f
    in go newProof paths
  go x _ = x
\end{lstlisting}

Finally, here's the implementation for the \textbf{Rule of Induction}:

\begin{lstlisting}
ruleInduction :: Eq a => Proof (PropCalc (FOL a)) -> Proof (PropCalc (FOL a)) -> Either String (Proof (PropCalc (FOL a)))
ruleInduction base (Proof ih@(PropVar (ForAll x (Imp y z)))) =
  -- in base' and conc, y is Proof y because it's an assumption
  let base' = substPropCalcAll (Proof y) (Var x) Z
      conc  = substPropCalcAll (Proof y) (Var x) (S (Var x)) in
  -- similarly, z is Proof z here
  if base' == base && conc == Proof z
  then Right $ Proof $ PropVar (ForAll x y)
  else Left "ruleInduction: Cannot construct proof"
ruleInduction x _ = Right x
\end{lstlisting}

\subsection{Peano's axioms}

Lastly, we now encode Peano’s axioms as follows:

\begin{lstlisting}
-- Peano axiom 1: forall a, not (S a = 0)
axiom1 a = Proof $ PropVar (ForAll a (Not (PropVar (Eq (S (Var a)) Z))))

-- Peano axiom 2: forall a, (a + 0) = a
axiom2 a = Proof $ PropVar (ForAll a (PropVar (Eq (Plus (Var a) Z) (Var a))))

-- Peano axiom 3: forall a, forall b, a + Sb = S(a + b)
axiom3 a b = Proof $ PropVar (ForAll a (PropVar (ForAll b (PropVar (Eq (Plus (Var a) (S (Var b))) (S (Plus (Var a) (Var b))))))))

-- Peano axiom 4: forall a, (a * 0) = 0
axiom4 a = Proof $ PropVar (ForAll a (PropVar (Eq (Mult (Var a) Z) Z)))

-- Peano axiom 5: forall a, forall b, a * Sb = (a * b + a)
axiom5 a b = Proof $ PropVar (ForAll a (PropVar (ForAll b (PropVar (Eq (Mult (Var a) (S (Var b))) (Plus (Mult (Var a) (Var b)) (Var a)))))))
\end{lstlisting}

Here are a few example usages; note how we use a rule from the system we defined earlier:

\begin{lstlisting}
> axiom4 P
|- All P:((P)*(0))=(0)
> ruleSpec (axiom4 P) P Z
|- ((0)*(0))=(0)
> ruleFantasy (\x -> ruleSpec (ruleGeneralize x Q (Just x)) P (S (Var P))) (PropVar (Eq (Var P) Z))
|- <(P)=(0)> -> <All Q:(P)=(0)>
\end{lstlisting}

Here's another, slightly longer proof, proving the other direction of the second axiom:

\begin{lstlisting}
> let egIndBase = ruleSpec (ruleSpec (axiom2 P) P Z) Q Z
|- ((0)+(0))=(0)
> let egIndHyp_1 = (axiom3 Q P)
|- All Q:All P:((Q)+(S(P)))=(S((Q)+(P)))
> let egIndHyp_2 = ruleSpec egIndHyp_1 Q Z
|- All P:((0)+(S(P)))=(S((0)+(P)))
> let egIndHyp_3 = ruleSpec egIndHyp_2 P (Var Q)
|- ((0)+(S(Q)))=(S((0)+(Q)))
> let egIndHyp_4 = ruleFantasy ruleAddS (PropVar (Eq (Plus Z (Var Q)) (Var Q)))
|- <((0)+(Q))=(Q)> -> <(S((0)+(Q)))=(S(Q))>
> let egIndHyp_5 = let rule formula = ruleTransitivity egIndHyp_3 formula in applyFOLRule [GoRight] rule egIndHyp_4
|- <((0)+(Q))=(Q)> -> <((0)+(S(Q)))=(S(Q))>
> let egIndHyp = ruleGeneralize egIndHyp_5 Q Nothing
|- All Q:<((0)+(Q))=(Q)> -> <((0)+(S(Q)))=(S(Q))>
> egInd = ruleInduction egIndBase egIndHyp
Right |- All Q:((0)+(Q))=(Q)
\end{lstlisting}

\section{Imperative language}

\subsection{Evaluation}

We provide the syntax, evaluation rules, and the implementation in Haskell of a simple language that is strongly normalizing.

To support variables, we introduce the notion of a context; one implementation in Haskell is simply a mapping from characters to numbers.

\begin{lstlisting}
type Context = M.Map Char Integer
\end{lstlisting}

As with previous implementations, we can keep things more generic:

\begin{lstlisting}
type Context a = M.Map a Integer
\end{lstlisting}

We list the evaluation rules for arithmetic expressions:

\[
\AxiomC{$(\#v, \$v') \in ctx$}
\RightLabel{(A-Eval-Var)}
\UnaryInfC{$\#v \underset{ctx}{\to} \$v'$}
\DisplayProof
\quad
\AxiomC{}
\RightLabel{(A-Eval-Z)}
\UnaryInfC{$Z \underset{ctx}{\to} 0$}
\DisplayProof
\quad
\AxiomC{$a \underset{ctx}{\to} a'$}
\RightLabel{(A-Eval-Succ)}
\UnaryInfC{$\texttt{S} \ a \underset{ctx}{\to} 1 + a_1'$}
\DisplayProof
\]
\hfill
\[
\AxiomC{$a_1 \underset{ctx}{\to} a_1' , a_2 \underset{ctx}{\to} a_2'$}
\RightLabel{(A-Eval-Plus)}
\UnaryInfC{$\texttt{Plus} \ a_1 \ a_2 \underset{ctx}{\to} a_1' + a_2'$}
\DisplayProof
\quad
\quad
\AxiomC{$a_1 \underset{ctx}{\to} a_1' , a_2 \underset{ctx}{\to} a_2'$}
\RightLabel{(A-Eval-Mult)}
\UnaryInfC{$\texttt{Mult} \ a_1 \ a_2 \underset{ctx}{\to} a_1' \cdot a_2'$}
\DisplayProof
\]

The arrow symbol $\underset{ctx}{\to}$ in the rules represents the actual evaluation of arithmetic expressions under context $ctx$.

Follows the implementation of these rules in Haskell:

\begin{lstlisting}
aeval :: (Ord a, Eq a) => Context a -> Arith a -> Integer
aeval ctx (Var v)        = ctx M.! v -- element may not exist
aeval ctx Z              = 0
aeval ctx (S x)          = 1 + aeval ctx x
aeval ctx (Plus a1 a2)   = aeval ctx a1 + aeval ctx a2
aeval ctx (Mult a1 a2)   = aeval ctx a1 * aeval ctx a2
\end{lstlisting}

Finally, the evaluation rules for boolean expressions:

\[
\AxiomC{$a_1 \underset{ctx}{\to} a_1' , a_2 \underset{ctx}{\to} a_2'$}
\RightLabel{(B-Eval-Eq)}
\UnaryInfC{$\texttt{Eq} \ a_1 \ a_2 \underset{ctx}{\Rightarrow} a_1' = a_2'$}
\DisplayProof
\AxiomC{$b \underset{ctx}{\Rightarrow} b'$}
\RightLabel{(B-Eval-ForAll)}
\UnaryInfC{$\texttt{ForAll} \ x \ b \underset{ctx}{\Rightarrow} b'$}
\DisplayProof
\AxiomC{$b \underset{ctx}{\Rightarrow} b'$}
\RightLabel{(B-Eval-Exists)}
\UnaryInfC{$\texttt{Exists} \ x \ b \underset{ctx}{\Rightarrow} b'$}
\DisplayProof
\]
\hfill
\[
\AxiomC{$b \underset{ctx}{\Rightarrow} b'$}
\RightLabel{(B-Eval-Not)}
\UnaryInfC{$\texttt{Not} \ b' \underset{ctx}{\Rightarrow} \neg b'$}
\DisplayProof
\quad
\AxiomC{$b_1 \underset{ctx}{\Rightarrow} b_1' , b_2 \underset{ctx}{\Rightarrow} b_2'$}
\RightLabel{(B-Eval-And)}
\UnaryInfC{$\texttt{And} \ b_1 \ b_2 \underset{ctx}{\Rightarrow} b_1' \land b_2'$}
\DisplayProof
\AxiomC{$b_1 \underset{ctx}{\Rightarrow} b_1' , b_2 \underset{ctx}{\Rightarrow} b_2'$}
\RightLabel{(B-Eval-Or)}
\UnaryInfC{$\texttt{Or} \ b_1 \ b_2 \underset{ctx}{\Rightarrow} b_1' \lor b_2'$}
\DisplayProof
\]
\hfill
\[
\AxiomC{$b_1 \underset{ctx}{\Rightarrow} \neg b_1' , b_2 \underset{ctx}{\Rightarrow} b_2'$}
\RightLabel{(B-Eval-Imp)}
\UnaryInfC{$\texttt{Imp} \ b_1 \ b_2 \underset{ctx}{\Rightarrow} b_1' \lor b_2'$}
\DisplayProof
\]

Similarly, the double right arrow symbol $\underset{ctx}{\Rightarrow}$ in the rules represents the actual evaluation of boolean expressions under context $ctx$.

We provide the implementation of these rules in Haskell:

\begin{lstlisting}
beval :: (Ord a, Eq a) => Context a -> PropCalc (FOL a) -> Bool
beval ctx (PropVar (Eq x y))     = aeval ctx x == aeval ctx y
beval ctx (PropVar (ForAll x y)) = beval ctx y
beval ctx (PropVar (Exists x y)) = beval ctx y
beval ctx (Not b1)               = not (beval ctx b1)
beval ctx (And b1 b2)            = beval ctx b1 && beval ctx b2
beval ctx (Or b1 b2)             = beval ctx b1 || beval ctx b2
beval ctx (Imp b1 b2)            = not (beval ctx b1) || beval ctx b2
\end{lstlisting}

Here are a few example evaluations:

\begin{lstlisting}
> let e = Plus (Var X) (S Z) in show e ++ " = " ++ show (aeval (M.fromList [(X, 5)]) e)
(X)+(S(0)) = 6
> let e = Plus (Var X) (S (S Z)) in show e ++ " = " ++ show (aeval (M.fromList [(X, 5)]) e)
(X)+(S(S(0))) = 7
> let e = PropVar $ Eq (Var X) (S Z) in show e ++ " = " ++ show (beval (M.fromList [(X, 5)]) e)
"(X)=(S(0)) = False"
> let e = PropVar $ Eq (Var X) (S (S (S (S (S Z))))) in show e ++ " = " ++ show (beval (M.fromList [(X, 5)]) e)
(X)=(S(S(S(S(S(0)))))) = True
\end{lstlisting}

\subsection{Commands}

We proceed with providing the syntax, evaluation rules, and the implementation in Haskell of an imperative language.

\begin{lstlisting}
data Command a =
  CSkip
  | CAssign a (Arith a)
  | CSequence (Command a) (Command a)
  | CIfElse (PropCalc (FOL a)) (Command a) (Command a)
  | CWhile (PropCalc (FOL a)) (Command a)
  | CAssert (PropCalc (FOL a)) (Command a) (PropCalc (FOL a))
\end{lstlisting}

That is, the language contains the minimum set of commands which make an imperative language:

\begin{itemize}
\item \texttt{CSkip} is the the no operation command - the empty statement.
\item \texttt{CAssign} will assign a value to a variable in a context.
\item \texttt{CSequence} will join two commands, which allows for the evaluation of commands in sequence.
\item \texttt{CIfElse} accepts a boolean and depending on its value either executes one command, or another.
\item \texttt{CWhile} accepts a boolean and keeps executing a command as long as the boolean is true.
\item \texttt{CAssert} accepts a precondition, a command, and a postcondition. The evaluation will be successful if the precondition and the postcondition are satisfied before and after executing the command, respectively.
\end{itemize}

We show the evaluation rules for this language:

\[
\AxiomC{}
\RightLabel{(C-Eval-Skip)}
\UnaryInfC{$\texttt{CSkip} \underset{ctx}{\mapsto} ctx$}
\DisplayProof
\]
\hfill
\[
\AxiomC{$v \underset{ctx}{\to} v'$}
\RightLabel{(C-Eval-Assign)}
\UnaryInfC{$\texttt{CAssign} \ c \ v \underset{ctx}{\mapsto} ctx \cup (c, v')$}
\DisplayProof
\quad
\AxiomC{$c_1 \underset{ctx}{\mapsto} ctx', c_2 \underset{ctx'}{\mapsto} ctx''$}
\RightLabel{(C-Eval-Sequence)}
\UnaryInfC{$\texttt{CSequence} \ c_1 \ c_2 \underset{ctx}{\mapsto} ctx''$}
\DisplayProof
\]
\hfill
\[
\AxiomC{$b \underset{ctx}{\Rightarrow} \texttt{True}, c_1 \underset{ctx}{\mapsto} ctx'$}
\RightLabel{(C-Eval-IfTrue)}
\UnaryInfC{$\texttt{CIfElse} \ b \ c_1 \ c_2 \underset{ctx}{\mapsto} ctx'$}
\DisplayProof
\quad
\AxiomC{$b \underset{ctx}{\Rightarrow} \texttt{False}, c_2 \underset{ctx}{\mapsto} ctx'$}
\RightLabel{(C-Eval-IfFalse)}
\UnaryInfC{$\texttt{CIfElse} \ b \ c_1 \ c_2 \underset{ctx}{\mapsto} ctx'$}
\DisplayProof
\]
\hfill
\[
\AxiomC{$b \underset{ctx}{\Rightarrow} \texttt{True}, c \underset{ctx}{\mapsto} ctx', \texttt{CWhile} \ b \ c \underset{ctx'}{\mapsto} ctx''$}
\RightLabel{(C-Eval-WhileTrue)}
\UnaryInfC{$\texttt{CWhile} \ b \ c \underset{ctx}{\mapsto} ctx''$}
\DisplayProof
\quad
\AxiomC{$b \underset{ctx}{\Rightarrow} \texttt{False}$}
\RightLabel{(C-Eval-WhileFalse)}
\UnaryInfC{$\texttt{CWhile} \ b \ c \underset{ctx}{\mapsto} ctx$}
\DisplayProof
\]
\hfill
\[
\AxiomC{$b_1 \underset{ctx}{\Rightarrow} \texttt{True}, c \underset{ctx}{\mapsto} ctx', b_2 \underset{ctx'}{\Rightarrow} \texttt{True}$}
\RightLabel{(C-Eval-Assert)}
\UnaryInfC{$\texttt{CAssert} \ b_1 \ c \ b_2$}
\DisplayProof
\]

The map arrow symbol $\underset{ctx}{\mapsto}$ in the rules represents the actual evaluation of a command under context $ctx$.

In Coq, each implementation of the rules would be represented at the type level. However, since we're working at the value level in Haskell, similarly as before we will rely on the \texttt{Either} data type to distinguish between provable and not provable terms.

\begin{lstlisting}
eval :: (Ord a, Eq a) => Context a -> Command a -> Either String (Context a)
eval ctx CSkip             = Right ctx
eval ctx (CAssign c v)     = Right $ M.insert c (aeval ctx v) ctx
eval ctx (CSequence c1 c2) = let ctx' = eval ctx c1 in whenRight ctx' (\ctx'' -> eval ctx'' c2)
eval ctx (CIfElse b c1 c2) = eval ctx $ if beval ctx b then c1 else c2
eval ctx (CWhile b c)      =
  if beval ctx b
  then let ctx' = eval ctx c in whenRight ctx' (\ctx'' -> eval ctx'' (CWhile b c))
  else Right ctx
eval ctx (CAssert b1 c b2) =
  if beval ctx b1
  then whenRight (eval ctx c)
       (\ctx' -> if beval ctx' b2
                  then Right ctx'
                  else Left "Post-condition does not match!")
  else Left "Pre-condition does not match!"
\end{lstlisting}

Note that this language is not strongly normalizing; consider the evaluation of \texttt{CWhile BTrue CSkip}.

As an example, the factorial program (sequence of commands) can be represented with the pseudo-code:

\begin{lstlisting}
Z := 1
Y := 1
while ~(Z = X)
  Y := Y * Z
  Z := Z + 1
\end{lstlisting}

That is, this program will calculate \texttt{Y := X!}. Here's an implementation of it in our language:

\begin{lstlisting}
> :{
| factX =
|   let l1 = CAssign Z (S Z)
|       l2 = CAssign Y (S Z)
|       l3 = CWhile (Not (PropVar $ Eq (Var Z) (S (Var X)))) (CSequence l4 l5)
|       l4 = CAssign Y (Mult (Var Y) (Var Z))
|       l5 = CAssign Z (S (Var Z))
|   in CSequence l1 (CSequence l2 l3)
| :}
> eval (M.fromList [(X, 5)]) factX
Right (fromList [(X,5),(Y,120),(Z,6)])
> let toArith x = if x == 0 then Z else S $ toArith (x - 1)
> let e = CAssert (PropVar $ Eq (toArith 5) (Var X)) factX (PropVar $ Eq (toArith 120) (Var Y)) in "Assert {X=5} factX {Y=120}: " ++ show (eval (M.fromList [(X, 5)]) e)
Assert {X=5} factX {Y=120}: Right (fromList [(X,5),(Y,120),(Z,6)])
> let e = CAssert (PropVar $ Eq (toArith 4) (Var X)) factX (PropVar $ Eq (toArith 120) (Var Y)) in "Assert {X=5} factX {Y=120}: " ++ show (eval (M.fromList [(X, 5)]) e)
Assert {X=5} factX {Y=120}: Left "Pre-condition does not match!"
\end{lstlisting}

\section{Hoare logic}

In the previous chapter, we implemented assertions (\texttt{CAssert}) at the run-time (\texttt{eval}) level. The biggest disadvantage of that is we have to do a full evaluation to deduce some facts about programs; considering the assertion example of the \texttt{factX} program, it has to actually evaluate the factorial to conclude something. This motivates the need for an additional evaluation strategy that will allow us to deduce facts about programs without doing a full evaluation.

Some programming languages, like Python, don't have a compile step and the \texttt{eval} function we provided is kind of equivalent to evaluating programs in Python. But some programming languages do have a compile step, like C or Haskell, and this compilation step can be beneficial in that it can do additional different checks, e.g., type checks. That's what we'll do here - implement a "compile"-time check (just another evaluation strategy) using some of the rules in Hoare's logic, and this check can be used to check the validity of a program, before fully evaluating it.

We list the rules of Hoare logic, some of which are outlined in the original paper\cite{b8}.

\[
\AxiomC{}
\RightLabel{(H-Skip)}
\UnaryInfC{$\{P\}\texttt{skip}\{P\}$}
\DisplayProof
\quad
\AxiomC{}
\RightLabel{(H-Assign)}
\UnaryInfC{$\{P[E/x]\}x:=E\{P\}$}
\DisplayProof
\]
\hfill
\[
\AxiomC{$P_1 \to P_2 , \{P_2\}S\{Q_2\} , Q_2 \to Q_1$}
\RightLabel{(H-Consequence)}
\UnaryInfC{$\{P_1\} S \{Q_1\}$}
\DisplayProof
\quad
\AxiomC{$\{P\}S\{Q\} , \{Q\}T\{R\}$}
\RightLabel{(H-Sequence)}
\UnaryInfC{$\{P\}S;T\{R\}$}
\DisplayProof
\]
\hfill
\[
\AxiomC{$\{B \land P\}S\{Q\} , \{\neg B \land P\}T\{Q\}$}
\RightLabel{(H-Conditional)}
\UnaryInfC{$\{P\}\texttt{if }B\texttt{ then }S\texttt{ else } T\{Q\}$}
\DisplayProof
\quad
\quad
\AxiomC{$\{B \land P\}S\{P\}$}
\RightLabel{(H-While)}
\UnaryInfC{$\{P\}\texttt{while }B\texttt{ do }S\{\neg B \land P\}$}
\DisplayProof
\]

\subsection{Implementation}

We represent the Hoare triple as a product of a command, a precondition (\texttt{(PropCalc (FOL a))}), and a postcondition (\texttt{(PropCalc (FOL a))}). In this case, the design decision is that pre/postconditions will be in the language of propositional calculus, but they can also be in a different language.

\begin{lstlisting}
data HoareTriple a =
  HoareTriple (PropCalc (FOL a)) (Command a) (PropCalc (FOL a))
\end{lstlisting}

Similarly as before, triples should not be constructed with \texttt{HoareTriple}, rather through the functions/rules that we provide next.

\subsubsection{H-Skip}

The Haskell implementation of the Hoare skip rule can be represented as follows:

\begin{lstlisting}
hoareSkip :: PropCalc (FOL a) -> HoareTriple a
hoareSkip q = HoareTriple q CSkip q
\end{lstlisting}

Note that we pass well-formed instead of proofs... the validity of the precondition is not being checked (since that would require evaluating \texttt{Aexp}/\texttt{Bexp} with a context); the proof merely states that assuming some precondition, a command produces some postcondition.

\begin{lstlisting}
> hoareSkip (BEq (ANum 3) (ANum 3))
{3 == 3} ; {3 == 3}
\end{lstlisting}

\subsubsection{H-Assign}

Let \texttt{Q[E/V]} denote the expression \texttt{Q} in which each free occurrence of \texttt{V} is replaced with \texttt{E}. Given an assignment command \texttt{V := E}, it should produce the triple where the precondition is \texttt{Q[E/V]} and the postcondition is \texttt{Q}, for any \texttt{Q}.

\begin{lstlisting}
hoareAssignment :: Eq a => a -> Arith a -> PropCalc (FOL a) -> HoareTriple a
hoareAssignment v e q =
  HoareTriple
  (fromProof (substPropCalcAll (Proof q) (Var v) e))
  (CAssign v e)
  q
\end{lstlisting}

We reuse substPropCalcAll from before

This implementation will rewrite a variable with an arithmetical expression within a boolean expression. We can now deduce some proofs, such as:

\begin{lstlisting}
> hoareAssignment 'X' (ANum 3) (BEq (AId 'X') (ANum 3))
{3 == 3} X := 3; {X == 3}
\end{lstlisting}

Given the precondition \texttt{3 = 3}, the command \texttt{X := 3} implies the postcondition \texttt{X = 3}.

\subsubsection{H-Consequence}

The consequence rule can be used to strengthen a precondition and/or weaken a postcondition in a Hoare triple.

Ideally, the implication in the consequence rule would represent the evaluation of a higher-order logic, but we're limiting it to optimization (our own small logic) for simplicity. That is, we use $\hookrightarrow$ in place of $\to$ in the rule.

In other words, the rule provides a way to transform a Hoare triple by embedding the result of an evaluation of a logic (in this case specifically, the optimization result of \texttt{boptimize}) into a Hoare triple.

\begin{lstlisting}
hoareConsequence :: Eq a => Proof (PropCalc (FOL a)) -> HoareTriple a -> Proof (PropCalc (FOL a)) -> Either String (HoareTriple a)
hoareConsequence (Proof (Imp p1 p2)) (HoareTriple p2' c q2) (Proof (Imp q2' q1))
  | p2 == p2' && q2 == q2' = Right $ HoareTriple p1 c q1
hoareConsequence _ _ _ = Left "hoareConsequence: Cannot construct proof"
\end{lstlisting}

As with \texttt{eval}, the \texttt{Either} data type is used to distinguish between provable and not provable terms.

For example, considering the \texttt{hoareAssignment} example we saw earlier, we can modify its precondition as follows:

\begin{lstlisting}
> hoareAssignment 'X' (ANum 3) (BEq (AId 'X') (ANum 3))
{3 == 3} X := 3; {X == 3}
> hoareConsequence (BAnd BTrue (BEq (ANum 3) (ANum 3))) (hoareAssignment 'X' (ANum 3) (BEq (AId 'X') (ANum 3))) (BEq (AId 'X') (ANum 3))
Right {TRUE && 3 == 3} X := 3; {X == 3}
\end{lstlisting}

\subsubsection{H-Sequence}

For the Hoare sequence rule, given two Hoare triples, the postcondition of the first triple must be equivalent to the precondition of the second triple, for some definition of equivalent; in this specific case, we rely on Haskell's \texttt{Eq}.

\begin{lstlisting}
hoareSequence :: Eq a => HoareTriple a -> HoareTriple a -> Either String (HoareTriple a)
hoareSequence (HoareTriple p c1 q1) (HoareTriple q2 c2 r)
  | q1 == q2  = Right $ HoareTriple p (CSequence c1 c2) r
hoareSequence _ _ = Left "hoareSequence: Cannot construct proof"
\end{lstlisting}

Several commands can be chained as follows:

\begin{lstlisting}
> let c1 = hoareAssignment 'Y' (ANum 1) (BAnd (BEq (AId 'Y') (ANum 1)) (BEq (AId 'X') (AId 'X')))
{1 == 1 && X == X} Y := 1; {Y == 1 && X == X}
> let c2 = hoareAssignment 'Z' (AId 'X') (BAnd (BEq (AId 'Y') (ANum 1)) (BEq (AId 'Z') (AId 'X')))
{Y == 1 && X == X} Z := X; {Y == 1 && Z == X}
> hoareSequence c1 c2
Right {1 == 1 && X == X} Y := 1; Z := X; {Y == 1 && Z == X}
\end{lstlisting}

\subsubsection{H-Conditional}

We provide an implementation for the Hoare conditional rule, covering both cases for commutativity of logical and.

\begin{lstlisting}
hoareConditional :: Eq a => HoareTriple a -> HoareTriple a -> Either String (HoareTriple a)
hoareConditional (HoareTriple (And b1 p1) c1 q1) (HoareTriple (And (Not b2) p2) c2 q2)
  | b1 == b2 &&
    p1 == p2 &&
    q1 == q2  = Right $ HoareTriple p1 (CIfElse b1 c1 c2) q1
hoareConditional (HoareTriple (And p1 b1) c1 q1) (HoareTriple (And (Not p2) b2) c2 q2)
  | b1 == b2 &&
    p1 == p2 &&
    q1 == q2  = Right $ HoareTriple p1 (CIfElse b1 c1 c2) q1
hoareConditional _ _ = Left "hoareConditional: Cannot construct proof"
\end{lstlisting}

For the purposes of example, we start by considering the command:

\begin{lstlisting}
> CIfElse (BNot (BEq (AId 'X') (ANum 0))) CSkip (CAssign 'X' (APlus (AId 'X') (ANum 1)))
(If (! (X == 0)) Then (;) Else (X := X + 1;));
\end{lstlisting}

The conditionals \texttt{B} and \texttt{P} are given in the code. Now, following the rule to construct a Hoare triple for this command, we have to construct two proofs:

\begin{itemize}
\item $\{X \neq 0 \land P\} \ ; \{Q\}$
\item $\{\neg(X \neq 0) \land P\} X := X + 1; \{Q\}$
\end{itemize}

\subsubsection{H-While}

In this part, we provide the implementation of the last and most important and complex rule.

\begin{lstlisting}
hoareWhile :: Eq a => HoareTriple a -> Either String (HoareTriple a)
hoareWhile (HoareTriple (And b p1) c p2)
  | p1 == p2  = Right $ HoareTriple p1 (CWhile b c) (And (Not b) p1)
hoareWhile (HoareTriple (And p1 b) c p2)
  | p1 == p2  = Right $ HoareTriple p1 (CWhile b c) (And (Not b) p1)
hoareWhile _ = Left "hoareWhile: Cannot construct proof"
\end{lstlisting}

The implementation for constructing the rule is straightforward, but the tricky part is that we have to properly construct the precondition and the postcondition so that they match the rule.

Similarly as we did with the \texttt{H-Conditional} rule, for the purposes of example, we will consider the command:

\begin{lstlisting}
> CWhile BTrue CSkip
(While (TRUE) Do {;});
\end{lstlisting}

In this case, we get that \texttt{B} is \texttt{BTrue} and \texttt{S} is \texttt{CSkip}. Thus, we must provide the Hoare triple $\{\top \land P \} \ ; \{P\}$. We can use \texttt{hoareSkip} together with \texttt{hoareConsequence} to construct such triple as follows:

\begin{lstlisting}
> let c = hoareSkip (BEq (ANum 0) (ANum 0))
{0 == 0} ; {0 == 0}
> hoareConsequence (BAnd BTrue (BEq (ANum 0) (ANum 0))) c (BEq (ANum 0) (ANum 0))
Right {TRUE && 0 == 0} ; {0 == 0}
\end{lstlisting}

Now we can deduce the following:

\begin{lstlisting}
> whenRight (hoareConsequence (BAnd BTrue (BEq (ANum 0) (ANum 0))) c (BEq (ANum 0) (ANum 0))) (\x -> hoareWhile x)
Right {0 == 0} (While (TRUE) Do {;}); {! (TRUE) && 0 == 0}
\end{lstlisting}

That is, from an infinite loop ($\bot$), follows anything (false).

\subsection{Example proofs}

So far we only looked at artificial examples, neatly crafted to match the specific forms that the rules accept. Even though the implementation we provided is simple enough, it can still be used to prove some useful real-world facts.

\subsubsection{Assignment (Swap)}

We will show a simple example of the assignment rule.

\begin{lstlisting}
> hoareAssignment 'a' (APlus (AId 'a') (AId 'b')) (BAnd (BEq (AMinus (AId 'a') (AId 'b')) (AId 'A')) (BEq (AId 'b') (AId 'B')))
{(a + b - b) == A && b == B} a := a + b; {(a - b) == A && b == B}
> hoareAssignment 'b' (AMinus (AId 'a') (AId 'b')) (BAnd (BEq (AId 'b') (AId 'A')) (BEq (AMinus (AId 'a') (AId 'b')) (AId 'B')))
{(a - b) == A && (a - (a - b)) == B} b := (a - b); {b == A && (a - b) == B}
> hoareAssignment 'a' (AMinus (AId 'a') (AId 'b')) (BAnd (BEq (AId 'b') (AId 'A')) (BEq (AId 'a') (AId 'B')))
{b == A && (a - b) == B} a := (a - b); {b == A && a == B}
\end{lstlisting}

That is, we start with the precondition that \texttt{a == A \&\& b == B} and we reach \texttt{b == A \&\& a == B}. We proved that this set of commands will swap the values between two variables. To make this proof more obvious, we can add two additional optimization rules that state $a + b - b = a$ and $a - (a - b) = b$:

\begin{lstlisting}
aoptimize q@(AMinus (APlus (AId a1) (AId a2)) (AId a3))  = if a2 == a3 then AId a1 else q
aoptimize q@(AMinus (AId a1) (AMinus (AId a2) (AId a3))) = if a1 == a2 then AId a3 else q
\end{lstlisting}

The proof can be completed with \texttt{hoareSequence} as follows:

\begin{lstlisting}
> whenRight (hoareSequence swap1 swap2) (\x -> hoareSequence x swap3)
Right {a == A && b == B} a := a + b; b := (a - b); a := (a - b); {b == A && a == B}
\end{lstlisting}

\subsubsection{While (Counting)}

We provide the implementation of a program that increases \texttt{X} up to 10:

\begin{lstlisting}
> :{
| countTo10 =
|   let l1 = CAssign 'X' $ ANum 0
|       l2 = CWhile (BLt (AId 'X') (ANum 10)) l3
|       l3 = CAssign 'X' (APlus (AId 'X') (ANum 1))
|   in CSequence l1 l2
> eval M.empty countTo10
Right (fromList [('X',10)])
\end{lstlisting}

Looking at the while rule, we can determine the values of \texttt{B} and \texttt{S} based on the command:

\[
\AxiomC{$\{x < 10 \land P\}\texttt{ x := x + 1 }\{P\}$}
\UnaryInfC{$\{P\}\texttt{while } x < 10\texttt{ do x := x + 1 }\{\neg (x < 10) \land P\}$}
\DisplayProof
\]

A sensible value for \texttt{P} would be $x \le 10$, because it holds wherever \texttt{P} is referenced in the formula.

\[
\AxiomC{$\{x < 10 \land x \le 10\}\texttt{ x := x + 1 }\{x \le 10 \}$}
\UnaryInfC{$\{x \le 10\}\texttt{while } x < 10\texttt{ do x := x + 1 }\{\neg (x < 10) \land x \le 10 \}$}
\DisplayProof
\]

Note that $\neg (x < 10) \land x \le 10$ simplifies to $x = 10$.

We should not use \texttt{HoareTriple} directly, but it can still be useful to show us what we need to prove:

\begin{lstlisting}
> let ht = HoareTriple (BAnd (BLt (AId 'X') (ANum 10)) (BLe (AId 'X') (ANum 10))) (CAssign 'X' (APlus (AId 'X') (ANum 1))) (BLe (AId 'X') (ANum 10))
{X < 10 && X <= 10} X := X + 1; {X <= 10}
> hoareWhile ht
Right {X <= 10} (While (X < 10) Do {X := X + 1;}); {! (X < 10) && X <= 10}
\end{lstlisting}

If we are able to produce \texttt{ht} using the rules, we'll be able to prove our statement. Using \texttt{hoareAssignment}, we can produce the following:

\begin{lstlisting}
> let ht = hoareAssignment 'X' (APlus (AId 'X') (ANum 1)) (BLe (AId 'X') (ANum 10))
{X + 1 <= 10} X := X + 1; {X <= 10}
\end{lstlisting}

If we tweak our optimization and substitution rules, we will be able to show that we can get from \texttt{X + 1 <= 10} to \texttt{X <= 9}, and then to \texttt{X < 10}, using the \texttt{H-Consequence} rule.

\section{Conclusion and future work}

Compile-time, run-time, etc. are all about having evaluations at different levels. There is still computation going on, but the computation strategies at the compile-time level may be different from those at the run-time level. A full evaluation of \texttt{Command} can be expensive, and sometimes even not terminate, and we wanted a way to deduce propositions without doing a full evaluation. We showed how to achieve this, by providing a simple implementation of Hoare logic as a proof of concept.

The evaluation strategies of a programming language directly affect how a programmer thinks. For example, if a programming language has a type system, the programmer will take advantage of it, subconsciously being aware of the (different) evaluation strategies for the type checker, in addition to the regular evaluation strategy for programs. If a programming language has the feature to verify properties about programs, such as Hoare logic, the programmer will be aware of this different evaluation strategy and use it to write more correct software.

Even though the mathematical formulas for Hoare logic look simple, implementing them is a different matter. The implementation details cover stuff like "what expressions do we want to support", "are we working with a strongly normalizing language", "what's the language that will represent propositions", etc. while these details are hidden in the mathematical representation of these formulas.

The biggest disadvantage of the provided implementation is that we had to manually add optimization rules, which is a bit tedious. Ideally, we would rely on a theorem prover that only contains a minimal set of axioms, and uses those to derive e.g. $x + 1 \le 10 \to x < 10$. Another disadvantage is that the implementation of \texttt{H-Consequence} is very simple, not really supporting logical implication as such. Finally, our system does not support quantifiers. Nevertheless, this paper serves as a good way to show the complexity and difficulty of designing such systems.

\section{Conflict of interest}

The author declares that they have no conflict of interest.

\begin{thebibliography}{1}

\bibitem{b1}
Rustan M. Leino
\newblock Dafny: An automatic program verifier for functional correctness
\newblock {\em International Conference on Logic for Programming Artificial Intelligence and Reasoning, pp. 348-370. Springer, Berlin, Heidelberg}, 2010.

\bibitem{b2}
Leonardo De Moura, Nikolaj Bjørner
\newblock Z3: An efficient SMT solver.
\newblock {\em International conference on Tools and Algorithms for the Construction and Analysis of Systems. Springer, Berlin, Heidelberg}, 2008.

\bibitem{b3}
Benjamin C. Pierce, Arthur Azevedo de Amorim, Chris Casinghino, Marco Gaboardi, Michael Greenberg, Cătălin Hriţcu, Vilhelm Sjöberg, Brent Yorgey
\newblock Logical Foundations
\newblock {\em Electronic textbook}, 2020.

\bibitem{b4}
Bruno Barras, Samuel Boutin, Cristina Cornes, Judicaël Courant, Jean-Christophe Filliâtre, et al.
\newblock The Coq Proof Assistant Reference Manual: Version 6.1
\newblock {\em [Research Report] RT-0203, INRIA}, 1997.

\bibitem{b5}
Boro Sitnikovski
\newblock Gentle Introduction to Dependent Types with Idris
\newblock {\em Leanpub/Amazon KDP}, 2018.

\bibitem{b6}
Miran Lipovaca
\newblock Learn You a Haskell For Great Good
\newblock {\em No Starch Press}, 2011.

\bibitem{b7}
Douglas Hofstadter
\newblock Godel, Escher, Bach: an Eternal Golden Braid
\newblock {\em Basic Books, Inc.}, 1979.

\bibitem{b8}
Charles A.R. Hoare
\newblock An axiomatic basis for computer programming
\newblock {\em Communications of the ACM, 12(10), pp.576-580}, 1969.

\end{thebibliography}

\end{document}
