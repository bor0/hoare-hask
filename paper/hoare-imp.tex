\documentclass{article}

\usepackage{arxiv}
\usepackage{bussproofs}
\usepackage{amsmath}
\usepackage{color}
\usepackage{listings}

\definecolor{dkgreen}{rgb}{0,0.6,0}
\definecolor{gray}{rgb}{0.5,0.5,0.5}
\definecolor{mauve}{rgb}{0.58,0,0.82}

\lstset{frame=tb,
  language=Haskell,
  aboveskip=3mm,
  belowskip=3mm,
  showstringspaces=false,
  columns=flexible,
  basicstyle={\small\ttfamily},
  numbers=none,
  numberstyle=\tiny\color{gray},
  keywordstyle=\color{blue},
  commentstyle=\color{dkgreen},
  stringstyle=\color{mauve},
  breaklines=true,
  breakatwhitespace=true,
  frame=none,
  tabsize=3
}

\title{Tutorial on implementing Hoare logic for imperative programs in Haskell}

\author{
  Boro Sitnikovski \\
  Skopje, North Macedonia \\
  \texttt{buritomath@gmail.com} \\
}

\begin{document}
\maketitle

\begin{abstract}
Using the programming language Haskell, we introduce an implementation of propositional calculus, number theory, and a simple imperative language that can evaluate arithmetic and boolean expressions. Finally, we provide an implementation of Hoare's logic which will allow us to deduce facts about programs without the need for a full evaluation.
\end{abstract}

\keywords{Imperative languages \and Functional languages \and Number Theory \and Peano axioms \and Hoare logic \and Formal verification \and Haskell}

\section{Introduction}

Nowadays, imperative programming languages run the world, to list a few popular ones: C, Python, JavaScript, PHP. Code is usually written in these languages by using an imperative style; that is, the computer is being told ("commanded") what to do and how to do it specifically. (The mathematical language is very unlike this, it is more declarative rather than imperative, that is, it doesn't care about the how.)

Since a programmer has to specify the exact "how", it is easy to make a programming error. In addition, given the popularity of these programming languages, there are many bugs in software applications that are programmed in them. This motivates for a way to formally verify certain properties about programs written in these languages. Hoare logic is one way to mechanically reason about computer programs.

We start by providing the implementation of the systems for manipulating logic and numbers. Further, we provide an implementation of an imperative language that will allow us to evaluate computer programs. We also provide an implementation of Hoare's logic, that will allow us to reason about computer programs, rather than evaluating them. The implementation of the imperative language will rely on logic for evaluating boolean expressions, while the implementation of Hoare's logic will rely on the number-theoretical system for proofs. Our implementation of Hoare's logic will be bottom-up, in the sense that we build the proofs from the ground up, in contrast to e.g. programming languages such as Dafny\cite{b1}, that build proofs from top to bottom. That is, in Dafny, the user provides a proposition and Dafny will derive the proof, automatically, using the automated theorem prover Z3\cite{b2}.

The programming language that we implement already has an implementation in Coq\cite{b3}. However, implementing a language in Haskell is more concerned about playing at the value level (and to some extent at the type level), whereas in a dependently typed language the focus is at the type level. Specifically for Hoare's logic, in Haskell we cannot use any of the meta language's constructs to do mathematical proofs, so we have to take care of these algorithms ourselves.

Haskell is not a strongly normalizing language, which means that not every evaluation necessarily terminates. However, in dependently typed languages, such as Coq\cite{b4}, the evaluation of proof terms (e.g. the type checker) is strongly normalizing, and this is what allows us to express mathematical proofs.

There are good introductory books on dependent types\cite{b3}. In some books, there is a gentler approach that might be handy for newcomers\cite{b5}. There are good introductions to Haskell as well\cite{b6}.

\section{Propositional calculus}

In this section, we provide an implementation of Propositional calculus, as described in GEB\cite{b7}.

\subsection{Syntax}

The syntax of the formal system expressed in BNF (Backus-Naur form) is:

\begin{lstlisting}
prop   ::= bterm | bterm brelop bterm | aterm arelop aterm | unop bterm
bterm  ::= P | Q | R
unop   ::= "!"
brelop ::= "&&" | "||" | "->"
\end{lstlisting}

The same syntax can be represented with the following Haskell code:

\begin{minipage}{0.49\textwidth}
\begin{lstlisting}
data PropCalc =
  P | Q | R
  | Not PropCalc
  | And PropCalc PropCalc
  | Or PropCalc PropCalc
  | Imp PropCalc PropCalc
\end{lstlisting}
\end{minipage}
\begin{minipage}{0.49\textwidth}
\begin{lstlisting}
data PropCalc a =
  PropVar a
  | Not (PropCalc a)
  | And (PropCalc a) (PropCalc a)
  | Or (PropCalc a) (PropCalc a)
  | Imp (PropCalc a) (PropCalc a)
\end{lstlisting}
\end{minipage}

We will use the more generic implementation on the right - instead of using specific variables, we rely on polymorphic types. This will allow us to later embed this system easily in other systems. With this data type, we have a way to represent some logical formulas, e.g. $A \land B$:

\begin{lstlisting}
> And (PropVar P) (PropVar Q)
<P> /\ <Q>
\end{lstlisting}

We also need a way to differentiate between well-formed formulas and theorems since not all well-formed formulas are theorems. For that, we provide the \texttt{Proof} data type constructor:

\begin{lstlisting}
newtype Proof a = Proof a deriving (Eq)

instance (Show a) => Show (Proof a) where
  show (Proof a) = "|- " ++ show a

fromProof :: Proof a -> a
fromProof (Proof a) = a
\end{lstlisting}

Note that \texttt{Proof \$ And (PropVar P) (PropVar Q)} is different from \texttt{And (PropVar P) (PropVar Q)}. This constructor must not be used directly; proofs should only be constructed given the rules, which we provide next.

\subsection{Rules}

These rules come from GEB, and we list them here for posterity:

\begin{itemize}
\item \textbf{Fantasy Rule (Implication)}: If $x$ were a theorem, $y$ would be a theorem ($<x \to y>$).
\item \textbf{Carry Over Rule}: Inside a fantasy, any theorem from the "reality" a level higher can be brought in and used.
\item \textbf{Contrapositive Rule}: $< x \to y>$ and $< \neg y \to \neg x>$ are interchangeable.
\item \textbf{De Morgan's Rule}: $< \neg x \land \neg y>$ and $\neg<x \lor y>$ are interchangeable.
\item \textbf{Double-Tilde Rule}: The string $\neg\neg$ can be deleted from any theorem. It can also be inserted into any theorem, provided that the resulting string is itself well-formed
\item \textbf{Joining Rule}: If $x$ and $y$ are theorems, then $<x \land y>$ is a theorem.
\item \textbf{Rule of Detachment}: If $x$ and $<x \to y>$ are both theorems, then $y$ is a theorem.
\item \textbf{Sep Rule}: If $<x \land y>$ is a theorem, then both $x$ and $y$ are theorems.
\item \textbf{Switcheroo Rule}: $<x \lor y>$ and $<\neg x \to y>$ are interchangeable.
\end{itemize}

For example, here's how we can implement \textbf{Sep Rule} and \textbf{Joining Rule} in Haskell:

\begin{lstlisting}
ruleJoin :: Proof (PropCalc a) -> Proof (PropCalc a) -> Proof (PropCalc a)
ruleJoin (Proof x) (Proof y) = Proof $ And x y

ruleSepL :: Proof (PropCalc a) -> Proof (PropCalc a)
ruleSepL (Proof (And x y)) = Proof x
ruleSepL x = x

ruleSepR :: Proof (PropCalc a) -> Proof (PropCalc a)
ruleSepR (Proof (And x y)) = Proof y
ruleSepR x = x
\end{lstlisting}

That is, we just lift the values from the object level to Haskell's level, and Haskell's neat type system takes care of everything else.

Perhaps the most powerful rule is the implication-intro (fantasy), and its counter-part implication-elim (detachment):

\begin{lstlisting}
ruleFantasy :: (Proof (PropCalc a) -> Proof (PropCalc a)) -> PropCalc a -> Proof (PropCalc a)
ruleFantasy f x = Proof $ Imp x $ fromProof (f (Proof x))

ruleDetachment :: Eq a => Proof (PropCalc a) -> Proof (PropCalc a) -> Either String (Proof (PropCalc a))
ruleDetachment (Proof x) (Proof (Imp x' y)) | x == x' = Right $ Proof y
ruleDetachment _ _ = Left "ruleDetachment: Cannot construct proof"
\end{lstlisting}

Note how we accept a non-proven term within \texttt{ruleFantasy}, whereas in other rules we accept proven terms. That is because the hypothesis needn't be necessarily true, it only states that "In the case this hypothesis is true, that is true". We also rely on Haskell's machinery for functions (lambda calculus) to take care of doing the actual work.

\begin{lstlisting}
> ruleFantasy (\pq -> ruleJoin (ruleSepR pq) (ruleSepL pq)) (And (PropVar P) (PropVar Q))
|- <<P> /\ <Q>> -> <<Q> /\ <P>>
\end{lstlisting}

For the other rule, we use \texttt{Either} to distinguish between provable and unprovable terms.

Here's another example implementation for the \textbf{Double-Tilde Rule}:

\begin{minipage}{0.49\textwidth}
\begin{lstlisting}
ruleDoubleTildeIntro :: Proof (PropCalc a) -> Proof (PropCalc a)
ruleDoubleTildeIntro (Proof x) = Proof $ Not (Not x)
\end{lstlisting}
\end{minipage}
\begin{minipage}{0.49\textwidth}
\begin{lstlisting}
ruleDoubleTildeElim :: Proof (PropCalc a) -> Proof (PropCalc a)
ruleDoubleTildeElim (Proof (Not (Not x))) = Proof x
ruleDoubleTildeElim x = x
\end{lstlisting}
\end{minipage}

However, in the current implementation, we can't apply a rule to e.g. $R$ within $P \land (Q \lor R)$, because it only accepts a full formula and doesn't know how to do replacements in its subformulas. To address this, we create a function that accepts a "path" (which subformula we apply it to), what rule should be applied, and the formula itself.

\begin{lstlisting}
data Pos = GoLeft | GoRight
type Path = [Pos]

applyPropRule :: Path -> (Proof (PropCalc a) -> Proof (PropCalc a)) -> Proof (PropCalc a) -> Proof (PropCalc a)
applyPropRule xs f (Proof x) = Proof $ go xs (\x -> fromProof $ f (Proof x)) x where
  go :: Path -> (PropCalc a -> PropCalc a) -> PropCalc a -> PropCalc a
  go (GoLeft:xs) f (Not x) = Not (go xs f x)
  go (GoLeft:xs) f (And x y) = And (go xs f x) y
  go (GoLeft:xs) f (Or x y) = Or (go xs f x) y
  go (GoLeft:xs) f (Imp x y) = Imp (go xs f x) y
  go (GoRight:xs) f (Not x) = Not (go xs f x)
  go (GoRight:xs) f (And x y) = And x (go xs f y)
  go (GoRight:xs) f (Or x y) = Or x (go xs f y)
  go (GoRight:xs) f (Imp x y) = Imp x (go xs f y)
  go _ f x = f x
\end{lstlisting}

Of course, going left or right doesn't make much sense for unary operators, so the implementation will just drill down in the \texttt{Not} operator if it finds either a left or a right. But, going left or right does make sense for binary operators - we drill on the left and the right argument respectively.

Now we can use it to apply the double negation rule to $R$ within $P \land (Q \lor R)$ as follows:

\begin{lstlisting}
> ruleFantasy (applyPropRule [GoRight, GoRight] ruleDoubleTildeIntro) (And (PropVar P) (Or (PropVar Q) (PropVar R)))
|- <<P> /\ <<Q> \/ <R>>> -> <<P> /\ <<Q> \/ <~~R>>>
\end{lstlisting}

\section{Number theory}

In this section we provide an implementation of a number-theoretical system, using the same literature (GEB).

\subsection{Syntax}

We start by introducing a language that can represent arithmetic expressions.

\begin{lstlisting}
digit  ::= "0" | "1" | ... | "8" | "9"
arith  ::= aterm | aterm relop aterm
number ::= - digit* | digit*
relop  ::= "+" | "*"
aterm  ::= arith | number | var
var    ::= A | B | C ... | Y | Z
\end{lstlisting}

Followed by a direct translation to Haskell code:

\begin{minipage}{0.49\textwidth}
\begin{lstlisting}
data Arith =
  Num Integer
  | Var Char
  | Plus Arith Arith
  | Mult Arith Arith
\end{lstlisting}
\end{minipage}
\begin{minipage}{0.49\textwidth}
\begin{lstlisting}
data Arith a =
  Var a
  | Z
  | S (Arith a)
  | Plus (Arith a) (Arith a)
  | Mult (Arith a) (Arith a)
\end{lstlisting}
\end{minipage}

As we did with \texttt{PropCalc} earlier, we will use the more generic variant on the right; getting rid off integers (implement our own zero and successor), and abstracting \texttt{Char}. Now we can represent things like $0 + 1 \cdot X$ as follows:

\begin{lstlisting}
> Plus Z (Mult (S Z) (Var X))
(0)+((S(0))*(X))
\end{lstlisting}

The next step is to implement the components from first-order logic (quantifiers and arithmetic equations).

\begin{minipage}{0.49\textwidth}
\begin{lstlisting}
fol    ::= eq arith arith | forall var prop | exists a prop
var    ::= A | B | C ... | Y | Z
\end{lstlisting}
\end{minipage}
\begin{minipage}{0.49\textwidth}
\begin{lstlisting}
data FOL a =
  Eq (Arith a) (Arith a)
  | ForAll a (PropCalc (FOL a))
  | Exists a (PropCalc (FOL a))
\end{lstlisting}
\end{minipage}

Note how we just embedded \texttt{PropCalc} within the system. Similarly, as before, this constructor must not be used directly; proofs should only be constructed given the rules, which we provide next.

\subsection{Rules}

Again, these formation rules come from GEB, and we list them here for posterity:

\begin{itemize}
\item \textbf{Rule of Specification}: Suppose $u$ is a variable that occurs inside the string $x$. If the string $\forall u:x$ is a theorem, then so is $x$, and so are any strings made from $x$ by replacing $u$, wherever it occurs, by the same term. (Restriction: The term that replaces $u$ must not contain any variable quantified in $x$.)
\item \textbf{Rule of Generalization}: Suppose $x$ is a theorem in which $u$, a variable, occurs free. Then $\forall u:x$ is a theorem. (Restriction: No generalization is allowed in a fantasy on any variable which appeared free in the fantasy's premise.)
\item \textbf{Rule of Interchange}: Suppose $u$ is a variable. Then the strings $\forall u:\neg$ and $\neg \exists u:$ are interchangeable anywhere inside any theorem.
\item \textbf{Rule of Existence}: Suppose a term (which may contain variables as long as they are free) appears once, or multiply, in a theorem. Then any (or several, or all) of the appearances of the term may be replaced by a variable that otherwise does not occur in the theorem, and the corresponding existential quantifier must be placed in front.
\item \textbf{Rule of Symmetry}: If $r=s$ is a theorem, then so is $s=r$
\item \textbf{Rule of Transitivity}: If $r=s$ and $s=t$ are theorems, then so is $r=t$
\item \textbf{Rule Add S}: If $r=t$ is a theorem, then $Sr=St$ is a theorem.
\item \textbf{Rule Drop S}: If $Sr=St$ is theorem, then $r=t$ is a theorem.
\item \textbf{Rule of Induction}: Let $X[u]$ represent a well-formed formula in which the variable $u$ is free, and $X[x/u]$ represent the same string, with each appearance of $u$ replaced by $x$. If both $\forall u:X[u] \to X[Su/u]$ and $X[0/u]$ are theorems, then $\forall u:X[u]$ is also a theorem.
\end{itemize}

To start, we provide an implementation of \texttt{substPropCalc}, which replaces all occurences of a term with another term in a formula:

\begin{lstlisting}
substPropCalc :: Eq a => Proof (PropCalc (FOL a)) -> Arith a -> Arith a -> Proof (PropCalc (FOL a))
substPropCalc (Proof f) v e = Proof $ go f v e where
  go :: Eq a => PropCalc (FOL a) -> Arith a -> Arith a -> PropCalc (FOL a)
  go (PropVar (Eq a b)) v e     = PropVar (Eq (substArith a v e) (substArith b v e))
  go (PropVar (ForAll x y)) v e = PropVar (ForAll x (go y v e))
  go (PropVar (Exists x y)) v e = PropVar (Exists x (go y v e))
  go (Not x) v e                = Not (go x v e)
  go (And x y) v e              = And (go x v e) (go y v e)
  go (Or x y) v e               = Or (go x v e) (go y v e)
  go (Imp x y) v e              = Imp (go x v e) (go y v e)
\end{lstlisting}

The function \texttt{substArith} is similar to \texttt{substPropCalc}, defined for its own data type. Next, we provide the functions \texttt{getArithVars} and \texttt{getBoundVars} that retrieve all variables in an arithmetic expression and all bound variables in a formula respectively.

\begin{minipage}{0.49\textwidth}
\begin{lstlisting}
getBoundVars :: Eq a => PropCalc (FOL a) -> [a]
getBoundVars x = nub $ go x where
  go (PropVar (ForAll s e)) = s : go e
  go (PropVar (Exists s e)) = s : go e
  go _ = []
\end{lstlisting}
\end{minipage}
\begin{minipage}{0.49\textwidth}
\begin{lstlisting}
getArithVars :: Eq a => Arith a -> [a]
getArithVars x = nub $ go x where
  go (Var a) = [a]
  go (S x) = go x
  go (Plus a b) = go a ++ go b
  go (Mult a b) = go a ++ go b
  go _ = []
\end{lstlisting}
\end{minipage}

Finally, we are now able to implement the \textbf{Rule of Specification}:

\begin{lstlisting}
ruleSpec :: Eq a => Proof (PropCalc (FOL a)) -> a -> Arith a -> Proof (PropCalc (FOL a))
ruleSpec (Proof f) v e = Proof $ go f v e where
  go :: Eq a => PropCalc (FOL a) -> a -> Arith a -> PropCalc (FOL a)
  go (PropVar (ForAll x y)) v e | x == v && not (any (`elem` getArithVars e) (getBoundVars y)) = fromProof $ substPropCalc (Proof y) (Var x) e
  go x _ _ = x
\end{lstlisting}

We can also implement the \textbf{Rule of Generalization} as follows:

\begin{lstlisting}
ruleGeneralize :: Eq a => Proof (PropCalc (FOL a)) -> a -> Maybe (Proof (PropCalc (FOL a))) -> Proof (PropCalc (FOL a))
ruleGeneralize (Proof f) v Nothing | v `notElem` getBoundVars f
  = Proof $ PropVar (ForAll v f)
ruleGeneralize (Proof f) v (Just premise) | v `notElem` getBoundVars f && v `notElem` getFreeVars (fromProof premise) -- fantasy vars
  = Proof $ PropVar (ForAll v f)
ruleGeneralize x _ _ = x
\end{lstlisting}

Another interesting rule is the existence rule; we can't simply substitute everything as we did within \texttt{ruleSpec}; we need to allow for one, or multiple terms replacement.

We're given the following:

\begin{itemize}
\item \texttt{applyFOLRule} and \texttt{applyArithRule}, both of which are similar to \texttt{applyPropRule}.
\item \texttt{applyFOLArithRule} which is a combination of \texttt{applyFOLRule} and \texttt{applyArithRule}, which takes a list of paths and then applies the rule to all of them.
\item \texttt{getTerm} - similar to \texttt{applyArithRule}, except that it returns a term instead of applying a rule to it. This function is used to check that each term is equivalent to others before applying the rule.
\end{itemize}

Now, the \textbf{Rule of Existence} can be easily implemented:

\begin{lstlisting}
ruleExistence :: Eq a => Proof (PropCalc (FOL a)) -> a -> [(Pos, Path, Path)] -> Proof (PropCalc (FOL a))
ruleExistence f v paths | allSame (map (\path -> getTerm path $ fromProof f) paths) =
  Proof $ PropVar (Exists v (fromProof (go f paths))) where
  go f ((pos, path1, path2):paths) =
    let newProof = applyFOLArithRule pos path1 path2 (\_ -> Var v) f
    in go newProof paths
  go x _ = x
ruleExistence x _ _ = x
\end{lstlisting}

Here's another example implementation, for the \textbf{Rule of Induction}:

\begin{lstlisting}
ruleInduction :: Eq a => Proof (PropCalc (FOL a)) -> Proof (PropCalc (FOL a)) -> Either String (Proof (PropCalc (FOL a)))
ruleInduction base (Proof ih@(PropVar (ForAll x (Imp y z)))) =
  -- in base' and conc, y is Proof y because it's an assumption
  let base' = substPropCalc (Proof y) (Var x) Z
      conc  = substPropCalc (Proof y) (Var x) (S (Var x)) in
  -- similarly, z is Proof z here
  if base' == base && conc == Proof z
  then Right $ Proof $ PropVar (ForAll x y)
  else Left "ruleInduction: Cannot construct proof"
ruleInduction x _ = Right x
\end{lstlisting}

\subsection{Peano's axioms}

Lastly, we now implement Peano's axioms as follows:

\begin{lstlisting}
-- Peano axiom 1: forall a, not (S a = 0)
axiom1 a = Proof $ PropVar (ForAll a (Not (PropVar (Eq (S (Var a)) Z))))

-- Peano axiom 2: forall a, (a + 0) = a
axiom2 a = Proof $ PropVar (ForAll a (PropVar (Eq (Plus (Var a) Z) (Var a))))

-- Peano axiom 3: forall a, forall b, a + Sb = S(a + b)
axiom3 a b = Proof $ PropVar (ForAll a (PropVar (ForAll b (PropVar (Eq (Plus (Var a) (S (Var b))) (S (Plus (Var a) (Var b))))))))

-- Peano axiom 4: forall a, (a * 0) = 0
axiom4 a = Proof $ PropVar (ForAll a (PropVar (Eq (Mult (Var a) Z) Z)))

-- Peano axiom 5: forall a, forall b, a * Sb = (a * b + a)
axiom5 a b = Proof $ PropVar (ForAll a (PropVar (ForAll b (PropVar (Eq (Mult (Var a) (S (Var b))) (Plus (Mult (Var a) (Var b)) (Var a)))))))
\end{lstlisting}

With a few example proofs:

\begin{minipage}[t]{0.49\textwidth}
$\star \ \forall A: \forall B: A + S(B) = S(A + B)$:

\begin{lstlisting}
-- lemma1 |- All A:All B:((A)+(S(B)))=(S((A)+(B)))
let step1 = axiom3 A B
    -- |- All B:((D)+(S(B)))=(S((D)+(B)))
    step2 = ruleSpec step1 A (Var D)
    -- |- ((D)+(S(S(C))))=(S((D)+(S(C))))
    step3 = ruleSpec step2 B (S (Var C))
    -- |- All B:((S(D))+(S(B)))=(S((S(D))+(B)))
    step4 = ruleSpec step1 A (S (Var D))
    -- |- ((S(D))+(S(C)))=(S((S(D))+(C)))
    step5 = ruleSpec step4 B (Var C)
    -- |- (S((S(D))+(C)))=((S(D))+(S(C)))
    step6 = ruleSymmetry step5
    -- All D:((D)+(S(C)))=((S(D))+(C))
    premise = PropVar (ForAll D (PropVar (Eq (Plus (Var D) (S (Var C))) (Plus (S (Var D)) (Var C)))))
    f premise =
     -- |- ((D)+(S(C)))=((S(D))+(C))
     let step8 = ruleSpec premise D (Var D)
         -- |- (S((D)+(S(C))))=(S((S(D))+(C)))
         step9 = ruleAddS step8
         -- |- ((D)+(S(S(C))))=(S((S(D))+(C)))
         step10 = ruleTransitivity step3 step9
         -- |- ((D)+(S(S(C))))=((S(D))+(S(C)))
         step11 = ruleTransitivity step10 step6
         -- |- All D:((D)+(S(S(C))))=((S(D))+(S(C)))
         in ruleGeneralize step11 D (Just premise)
    -- |- <All D:((D)+(S(C)))=((S(D))+(C))> -> <All D:((D)+(S(S(C))))=((S(D))+(S(C)))>
    step7 = ruleFantasy f premise in
    -- |- All C:<All D:((D)+(S(C)))=((S(D))+(C))> -> <All D:((D)+(S(S(C))))=((S(D))+(S(C)))>
    ruleGeneralize step7 C Nothing
\end{lstlisting}
\end{minipage}
\begin{minipage}[t]{0.49\textwidth}
$\star \ \forall D: \forall B: D + S(Z) = S(D) + Z$:

\begin{lstlisting}
-- lemma2 |- All D:((D)+(S(0)))=((S(D))+(0))
let step1 = axiom3 A B
    -- |- All B:((D)+(S(B)))=(S((D)+(B)))
    step2 = ruleSpec step1 A (Var D)
    -- |- ((D)+(S(S(C))))=(S((D)+(S(C))))
    step3 = ruleSpec step2 B (S (Var C))
    -- |- ((D)+(S(0)))=(S((D)+(0)))
    step4 = ruleSpec step2 B Z
    -- |- All A:((A)+(0))=(A)
    step5 = axiom2 A
    -- |- ((D)+(0))=(D)
    step6 = ruleSpec step5 A (Var D)
    -- |- (S((D)+(0)))=(S(D))
    step7 = ruleAddS step6
    -- |- ((D)+(S(0)))=(S(D))
    step8 = ruleTransitivity step4 step7
    -- |- ((S(D))+(0))=(S(D))
    step9 = ruleSpec step5 A (S (Var D))
    -- |- (S(D))=((S(D))+(0))
    step10 = ruleSymmetry step9
    -- |- ((D)+(S(0)))=((S(D))+(0))
    step11 = ruleTransitivity step8 step10 in
    -- |- All D:((D)+(S(0)))=((S(D))+(0))
    ruleGeneralize step11 D Nothing
\end{lstlisting}

$\star \ \forall C: \forall D: D + S(C) = S(D) + C$:

\begin{lstlisting}
-- theorem1 Right |- All C:All D:((D)+(S(C)))=((S(D))+(C))
let theorem1 = ruleInduction lemma2 lemma1
\end{lstlisting}
\end{minipage}

\section{Imperative language}

\subsection{Arithmetic and boolean expressions}

We provide the syntax, evaluation rules, and the implementation in Haskell of a simple imperative language.

To start with, we add support for variables by introducing the notion of a context; one implementation in Haskell is simply a mapping from characters to numbers.

\begin{minipage}{0.49\textwidth}
\begin{lstlisting}
type Context = M.Map Char Integer
\end{lstlisting}
\end{minipage}
\begin{minipage}{0.49\textwidth}
\begin{lstlisting}
type Context a = M.Map a Integer
\end{lstlisting}
\end{minipage}

However, as with previous implementations, we keep things more generic and use the implementation on the right.

We list the evaluation rules for arithmetic expressions:

\[
\AxiomC{$(\#v, \$v') \in ctx$}
\RightLabel{(A-Eval-Var)}
\UnaryInfC{$\#v \underset{ctx}{\to} \$v'$}
\DisplayProof
\quad
\AxiomC{}
\RightLabel{(A-Eval-Z)}
\UnaryInfC{$Z \underset{ctx}{\to} 0$}
\DisplayProof
\quad
\AxiomC{$a \underset{ctx}{\to} a'$}
\RightLabel{(A-Eval-Succ)}
\UnaryInfC{$\texttt{S} \ a \underset{ctx}{\to} 1 + a_1'$}
\DisplayProof
\]
\hfill
\[
\AxiomC{$a_1 \underset{ctx}{\to} a_1' , a_2 \underset{ctx}{\to} a_2'$}
\RightLabel{(A-Eval-Plus)}
\UnaryInfC{$\texttt{Plus} \ a_1 \ a_2 \underset{ctx}{\to} a_1' + a_2'$}
\DisplayProof
\quad
\quad
\AxiomC{$a_1 \underset{ctx}{\to} a_1' , a_2 \underset{ctx}{\to} a_2'$}
\RightLabel{(A-Eval-Mult)}
\UnaryInfC{$\texttt{Mult} \ a_1 \ a_2 \underset{ctx}{\to} a_1' \cdot a_2'$}
\DisplayProof
\]

The arrow symbol $\underset{ctx}{\to}$ in the rules represents the actual evaluation of arithmetic expressions under context $ctx$.

Follows the implementation of these rules in Haskell:

\begin{lstlisting}
aeval :: (Ord a, Eq a) => Context a -> Arith a -> Integer
aeval ctx (Var v)        = ctx M.! v -- element may not exist
aeval ctx Z              = 0
aeval ctx (S x)          = 1 + aeval ctx x
aeval ctx (Plus a1 a2)   = aeval ctx a1 + aeval ctx a2
aeval ctx (Mult a1 a2)   = aeval ctx a1 * aeval ctx a2
\end{lstlisting}

Finally, the evaluation rules for boolean expressions:

\[
\AxiomC{$a_1 \underset{ctx}{\to} a_1' , a_2 \underset{ctx}{\to} a_2'$}
\RightLabel{(B-Eval-Eq)}
\UnaryInfC{$\texttt{Eq} \ a_1 \ a_2 \underset{ctx}{\Rightarrow} a_1' = a_2'$}
\DisplayProof
\AxiomC{$b \underset{ctx}{\Rightarrow} b'$}
\RightLabel{(B-Eval-ForAll)}
\UnaryInfC{$\texttt{ForAll} \ x \ b \underset{ctx}{\Rightarrow} b'$}
\DisplayProof
\AxiomC{$b \underset{ctx}{\Rightarrow} b'$}
\RightLabel{(B-Eval-Exists)}
\UnaryInfC{$\texttt{Exists} \ x \ b \underset{ctx}{\Rightarrow} b'$}
\DisplayProof
\]
\hfill
\[
\AxiomC{$b \underset{ctx}{\Rightarrow} b'$}
\RightLabel{(B-Eval-Not)}
\UnaryInfC{$\texttt{Not} \ b' \underset{ctx}{\Rightarrow} \neg b'$}
\DisplayProof
\quad
\AxiomC{$b_1 \underset{ctx}{\Rightarrow} b_1' , b_2 \underset{ctx}{\Rightarrow} b_2'$}
\RightLabel{(B-Eval-And)}
\UnaryInfC{$\texttt{And} \ b_1 \ b_2 \underset{ctx}{\Rightarrow} b_1' \land b_2'$}
\DisplayProof
\AxiomC{$b_1 \underset{ctx}{\Rightarrow} b_1' , b_2 \underset{ctx}{\Rightarrow} b_2'$}
\RightLabel{(B-Eval-Or)}
\UnaryInfC{$\texttt{Or} \ b_1 \ b_2 \underset{ctx}{\Rightarrow} b_1' \lor b_2'$}
\DisplayProof
\]
\hfill
\[
\AxiomC{$b_1 \underset{ctx}{\Rightarrow} \neg b_1' , b_2 \underset{ctx}{\Rightarrow} b_2'$}
\RightLabel{(B-Eval-Imp)}
\UnaryInfC{$\texttt{Imp} \ b_1 \ b_2 \underset{ctx}{\Rightarrow} b_1' \lor b_2'$}
\DisplayProof
\]

Similarly, the double right arrow symbol $\underset{ctx}{\Rightarrow}$ in the rules represents the actual evaluation of boolean expressions under context $ctx$.

We provide the implementation of these rules in Haskell:

\begin{lstlisting}
beval :: (Ord a, Eq a) => Context a -> PropCalc (FOL a) -> Bool
beval ctx (PropVar (Eq x y))     = aeval ctx x == aeval ctx y
beval ctx (PropVar (ForAll x y)) = beval ctx y
beval ctx (PropVar (Exists x y)) = beval ctx y
beval ctx (Not b1)               = not (beval ctx b1)
beval ctx (And b1 b2)            = beval ctx b1 && beval ctx b2
beval ctx (Or b1 b2)             = beval ctx b1 || beval ctx b2
beval ctx (Imp b1 b2)            = not (beval ctx b1) || beval ctx b2
\end{lstlisting}

Note that we ignore quantifiers in this implementation because we only rely on propositional logic and substitute variables based on the context.

\begin{lstlisting}
> let e = Plus (Var X) (S Z) in show e ++ " = " ++ show (aeval (M.fromList [(X, 5)]) e)
(X)+(S(0)) = 6
> let e = Plus (Var X) (S (S Z)) in show e ++ " = " ++ show (aeval (M.fromList [(X, 5)]) e)
(X)+(S(S(0))) = 7
> let e = PropVar $ Eq (Var X) (S Z) in show e ++ " = " ++ show (beval (M.fromList [(X, 5)]) e)
"(X)=(S(0)) = False"
> let e = PropVar $ Eq (Var X) (S (S (S (S (S Z))))) in show e ++ " = " ++ show (beval (M.fromList [(X, 5)]) e)
(X)=(S(S(S(S(S(0)))))) = True
\end{lstlisting}

\subsection{Commands}

We proceed with providing the syntax, evaluation rules, and the implementation in Haskell of an imperative language.

\begin{lstlisting}
data Command a =
  CSkip
  | CAssign a (Arith a)
  | CSequence (Command a) (Command a)
  | CIfElse (PropCalc (FOL a)) (Command a) (Command a)
  | CWhile (PropCalc (FOL a)) (Command a)
  | CAssert (PropCalc (FOL a)) (Command a) (PropCalc (FOL a))
\end{lstlisting}

That is, the language contains the minimum set of commands which make an imperative language:

\begin{itemize}
\item \texttt{CSkip} is the the no operation command - the empty statement.
\item \texttt{CAssign} will assign a value to a variable in a context.
\item \texttt{CSequence} will join two commands, which allows for the evaluation of commands in sequence.
\item \texttt{CIfElse} accepts a boolean and depending on its value either executes one command, or another.
\item \texttt{CWhile} accepts a boolean and keeps executing a command as long as the boolean is true.
\item \texttt{CAssert} accepts a precondition, a command, and a postcondition. The evaluation will be successful if the precondition and the postcondition are satisfied before and after executing the command, respectively.
\end{itemize}

We show the evaluation rules for this language:

\[
\AxiomC{}
\RightLabel{(C-Eval-Skip)}
\UnaryInfC{$\texttt{CSkip} \underset{ctx}{\mapsto} ctx$}
\DisplayProof
\]
\hfill
\[
\AxiomC{$v \underset{ctx}{\to} v'$}
\RightLabel{(C-Eval-Assign)}
\UnaryInfC{$\texttt{CAssign} \ c \ v \underset{ctx}{\mapsto} ctx \cup (c, v')$}
\DisplayProof
\quad
\AxiomC{$c_1 \underset{ctx}{\mapsto} ctx', c_2 \underset{ctx'}{\mapsto} ctx''$}
\RightLabel{(C-Eval-Sequence)}
\UnaryInfC{$\texttt{CSequence} \ c_1 \ c_2 \underset{ctx}{\mapsto} ctx''$}
\DisplayProof
\]
\hfill
\[
\AxiomC{$b \underset{ctx}{\Rightarrow} \texttt{True}, c_1 \underset{ctx}{\mapsto} ctx'$}
\RightLabel{(C-Eval-IfTrue)}
\UnaryInfC{$\texttt{CIfElse} \ b \ c_1 \ c_2 \underset{ctx}{\mapsto} ctx'$}
\DisplayProof
\quad
\AxiomC{$b \underset{ctx}{\Rightarrow} \texttt{False}, c_2 \underset{ctx}{\mapsto} ctx'$}
\RightLabel{(C-Eval-IfFalse)}
\UnaryInfC{$\texttt{CIfElse} \ b \ c_1 \ c_2 \underset{ctx}{\mapsto} ctx'$}
\DisplayProof
\]
\hfill
\[
\AxiomC{$b \underset{ctx}{\Rightarrow} \texttt{True}, c \underset{ctx}{\mapsto} ctx', \texttt{CWhile} \ b \ c \underset{ctx'}{\mapsto} ctx''$}
\RightLabel{(C-Eval-WhileTrue)}
\UnaryInfC{$\texttt{CWhile} \ b \ c \underset{ctx}{\mapsto} ctx''$}
\DisplayProof
\quad
\AxiomC{$b \underset{ctx}{\Rightarrow} \texttt{False}$}
\RightLabel{(C-Eval-WhileFalse)}
\UnaryInfC{$\texttt{CWhile} \ b \ c \underset{ctx}{\mapsto} ctx$}
\DisplayProof
\]
\hfill
\[
\AxiomC{$b_1 \underset{ctx}{\Rightarrow} \texttt{True}, c \underset{ctx}{\mapsto} ctx', b_2 \underset{ctx'}{\Rightarrow} \texttt{True}$}
\RightLabel{(C-Eval-Assert)}
\UnaryInfC{$\texttt{CAssert} \ b_1 \ c \ b_2$}
\DisplayProof
\]

The map arrow symbol $\underset{ctx}{\mapsto}$ in the rules represents the actual evaluation of a command under context $ctx$.

In Coq, each implementation of the rules would be represented at the type level. However, since we're working at the value level in Haskell, similarly as before we will rely on the \texttt{Either} data type to distinguish between provable and not provable terms.

\begin{lstlisting}
eval :: (Ord a, Eq a) => Context a -> Command a -> Either String (Context a)
eval ctx CSkip             = Right ctx
eval ctx (CAssign c v)     = Right $ M.insert c (aeval ctx v) ctx
eval ctx (CSequence c1 c2) = let ctx' = eval ctx c1 in whenRight ctx' (\ctx'' -> eval ctx'' c2)
eval ctx (CIfElse b c1 c2) = eval ctx $ if beval ctx b then c1 else c2
eval ctx (CWhile b c)      =
  if beval ctx b
  then let ctx' = eval ctx c in whenRight ctx' (\ctx'' -> eval ctx'' (CWhile b c))
  else Right ctx
eval ctx (CAssert b1 c b2) =
  if beval ctx b1
  then whenRight (eval ctx c)
       (\ctx' -> if beval ctx' b2
                  then Right ctx'
                  else Left "Assert: Post-condition does not match!")
  else Left "Assert: Pre-condition does not match!"
\end{lstlisting}

Note that this language is not strongly normalizing; consider the evaluation of \texttt{CWhile BTrue CSkip}.

As an example, a program that counts from 0 to $B$ can be represented as follows:

\begin{minipage}{0.29\textwidth}
\begin{lstlisting}
A := 0
while ~(A = B)
  A := 1 + A
\end{lstlisting}
\end{minipage}
\begin{minipage}{0.69\textwidth}
\begin{lstlisting}
countToB =
  let l1 = CAssign A Z
      l2 = CWhile (Not (PropVar $ Eq (Var A) (Var B))) l3
      l3 = CAssign A (S (Var A))
  in CSequence l1 l2
\end{lstlisting}
\end{minipage}

Here's an example evaluation with assertion checks:

\begin{lstlisting}
> eval (M.fromList [(B, 3)]) countToB
Right (fromList [(A,3),(B,3)])
> let toArith x = if x == 0 then Z else S $ toArith (x - 1)
> let e = CAssert (PropVar $ Eq (toArith 5) (Var B)) countToB (PropVar $ Eq (toArith 5) (Var A)) in "Assert {B=5} countToB {A=5}: " ++ show (eval (M.fromList [(B, 5)]) e)
Assert {B=5} countToB {A=5}: Right (fromList [(A,5),(B,5)])
> let e = CAssert (PropVar $ Eq (toArith 4) (Var B)) countToB (PropVar $ Eq (toArith 5) (Var A)) in "Assert {B=5} countToB {A=5}: " ++ show (eval (M.fromList [(B, 5)]) e)
Assert {B=5} countToB {A=5}: Left "Pre-condition does not match!"
\end{lstlisting}

\section{Hoare logic}

In the previous chapter, we implemented assertions (\texttt{CAssert}) at the run-time (\texttt{eval}) level. The biggest disadvantage of that is we have to do a full evaluation to deduce some facts about programs; considering the assertion example of the \texttt{countToB} program, it has to actually evaluate the program to assert something. This motivates the need for an additional evaluation strategy that will allow us to deduce facts about programs without doing a full evaluation.

Some programming languages, like Python, don't have a compile step and the \texttt{eval} function we provided is kind of equivalent to evaluating programs in Python. But some programming languages do have a compile step, like C or Haskell, and this compilation step can be beneficial in that it can do additional different checks, e.g., type checks. That's what we'll do here - implement a "compile"-time check (just another evaluation strategy) using some of the rules in Hoare's logic, and this check can be used to check the validity of a program, before fully evaluating it.

We list the rules of Hoare logic, some of which are outlined in the original paper\cite{b8}.

\[
\AxiomC{}
\RightLabel{(H-Skip)}
\UnaryInfC{$\{P\}\texttt{skip}\{P\}$}
\DisplayProof
\quad
\AxiomC{}
\RightLabel{(H-Assign)}
\UnaryInfC{$\{P[E/x]\}x:=E\{P\}$}
\DisplayProof
\]
\hfill
\[
\AxiomC{$P_1 \to P_2 , \{P_2\}S\{Q_2\} , Q_2 \to Q_1$}
\RightLabel{(H-Consequence)}
\UnaryInfC{$\{P_1\} S \{Q_1\}$}
\DisplayProof
\quad
\AxiomC{$\{P\}S\{Q\} , \{Q\}T\{R\}$}
\RightLabel{(H-Sequence)}
\UnaryInfC{$\{P\}S;T\{R\}$}
\DisplayProof
\]
\hfill
\[
\AxiomC{$\{B \land P\}S\{Q\} , \{\neg B \land P\}T\{Q\}$}
\RightLabel{(H-Conditional)}
\UnaryInfC{$\{P\}\texttt{if }B\texttt{ then }S\texttt{ else } T\{Q\}$}
\DisplayProof
\quad
\quad
\AxiomC{$\{B \land P\}S\{P\}$}
\RightLabel{(H-While)}
\UnaryInfC{$\{P\}\texttt{while }B\texttt{ do }S\{\neg B \land P\}$}
\DisplayProof
\]

\subsection{Implementation}

We represent the Hoare triple as a product of a command, a precondition (\texttt{(PropCalc (FOL a))}), and a postcondition (\texttt{(PropCalc (FOL a))}).

\begin{lstlisting}
data HoareTriple a =
  HoareTriple (PropCalc (FOL a)) (Command a) (PropCalc (FOL a))
\end{lstlisting}

Similarly, as before, triples should not be constructed with \texttt{HoareTriple}, rather through the functions/rules that we provide next.

\subsubsection{H-Skip}

The Haskell implementation of the Hoare skip rule can be represented as follows:

\begin{lstlisting}
hoareSkip :: PropCalc (FOL a) -> HoareTriple a
hoareSkip q = HoareTriple q CSkip q
\end{lstlisting}

Note that the rule accepts well-formed formulas instead of proven ones, as the validity of the precondition is not being checked; the triple merely states that assuming some precondition, a command produces some postcondition.

\begin{lstlisting}
> hoareSkip (PropVar (Eq (Var A) (S (S (S Z)))))
{(A)=(S(S(S(0))))} ; {(A)=(S(S(S(0))))}
\end{lstlisting}

\subsubsection{H-Assign}

Let \texttt{Q[E/V]} denote the expression \texttt{Q} in which each free occurrence of \texttt{V} is replaced with \texttt{E}. Given an assignment command \texttt{V := E}, it should produce the triple where the precondition is \texttt{Q[E/V]} and the postcondition is \texttt{Q}, for any \texttt{Q}.

\begin{lstlisting}
hoareAssignment :: Eq a => a -> Arith a -> PropCalc (FOL a) -> HoareTriple a
hoareAssignment v e q = HoareTriple (fromProof (substPropCalc (Proof q) (Var v) e)) (CAssign v e) q
\end{lstlisting}

Since the implementation relies on \texttt{PropCalc}, it's natural to re-use \texttt{substPropCalc}. Example deduction:

\begin{lstlisting}
> hoareAssignment A (Plus (Var B) (S Z)) (And (PropVar (Eq (Var A) (S (S Z)))) (PropVar (Eq Z Z)))
{<((B)+(S(0)))=(S(S(0)))> /\ <(0)=(0)>} A := (B)+(S(0)); {<(A)=(S(S(0)))> /\ <(0)=(0)>}
\end{lstlisting}

\subsubsection{H-Consequence}

The consequence rule can be used to strengthen (make more specific) a precondition and/or weaken (make more generic) a postcondition in a Hoare triple.

The implication in the consequence rule represents an "evaluation" from the previously defined logic. In other words, the rule provides a way to transform a Hoare triple by embedding the result of an evaluation of a logic (another system) into a Hoare triple.

\begin{lstlisting}
hoareConsequence :: Eq a => Proof (PropCalc (FOL a)) -> HoareTriple a -> Proof (PropCalc (FOL a)) -> Either String (HoareTriple a)
hoareConsequence (Proof (Imp p1 p2)) (HoareTriple p2' c q2) (Proof (Imp q2' q1))
  | p2 == p2' && q2 == q2' = Right $ HoareTriple p1 c q1
hoareConsequence _ _ _ = Left "hoareConsequence: Cannot construct proof"
\end{lstlisting}

As with \texttt{eval}, the \texttt{Either} data type is used to distinguish between provable and not provable terms.

For example, considering the \texttt{hoareAssignment} example we saw earlier, we can modify its postcondition (weaken) as follows:

\begin{lstlisting}
> let tripleEg = hoareAssignment A (Plus (Var B) (S Z)) (And (PropVar (Eq (Var A) (S (S Z)))) (PropVar (Eq Z Z)))
{<((B)+(S(0)))=(S(S(0)))> /\ <(0)=(0)>} A := (B)+(S(0)); {<(A)=(S(S(0)))> /\ <(0)=(0)>}
> let pre = ruleFantasy id $ And (PropVar (Eq (Plus (Var B) (S Z)) (S (S Z)))) (PropVar (Eq Z Z))
|- <<((B)+(S(0)))=(S(S(0)))> /\ <(0)=(0)>> -> <<((B)+(S(0)))=(S(S(0)))> /\ <(0)=(0)>>
> let post = ruleFantasy ruleSepL $ And (PropVar (Eq (Var A) (S (S Z)))) (PropVar (Eq Z Z))
|- <<(A)=(S(S(0)))> /\ <(0)=(0)>> -> <(A)=(S(S(0)))>
> hoareConsequence pre tripleEg post
Right {<((B)+(S(0)))=(S(S(0)))> /\ <(0)=(0)>} A := (B)+(S(0)); {(A)=(S(S(0)))}
\end{lstlisting}

For another example, here's how we can modify the precondition (strengthen):

\begin{lstlisting}
> let tripleEg = hoareAssignment A (Plus (Var B) (S Z)) (PropVar (Eq (Var A) (S (S Z))))
{((B)+(S(0)))=(S(S(0)))} A := (B)+(S(0)); {(A)=(S(S(0)))}
> let pre = ruleFantasy ruleSepL $ And (PropVar (Eq (Plus (Var B) (S Z)) (S (S Z)))) (PropVar (Eq Z Z))
|- <<((B)+(S(0)))=(S(S(0)))> /\ <(0)=(0)>> -> <((B)+(S(0)))=(S(S(0)))>
> let post = ruleFantasy id $ PropVar (Eq (Var A) (S (S Z)))
|- <(A)=(S(S(0)))> -> <(A)=(S(S(0)))>
> hoareConsequence pre tripleEg post
Right {<((B)+(S(0)))=(S(S(0)))> /\ <(0)=(0)>} A := (B)+(S(0)); {(A)=(S(S(0)))}
\end{lstlisting}

\subsubsection{H-Sequence}

For the Hoare sequence rule, given two Hoare triples, the postcondition of the first triple must be equivalent to the precondition of the second triple, for some definition of equivalent; in this specific case, we rely on Haskell's \texttt{Eq}.

\begin{lstlisting}
hoareSequence :: Eq a => HoareTriple a -> HoareTriple a -> Either String (HoareTriple a)
hoareSequence (HoareTriple p c1 q1) (HoareTriple q2 c2 r)
  | q1 == q2  = Right $ HoareTriple p (CSequence c1 c2) r
hoareSequence _ _ = Left "hoareSequence: Cannot construct proof"
\end{lstlisting}

Several commands can be chained as follows:

\begin{lstlisting}
> let c1 = hoareAssignment B (S Z) (And (PropVar $ Eq (Var B) (S Z)) (PropVar $ Eq (Var A) (Var A)))
{<(S(0))=(S(0))> /\ <(A)=(A)>} B := S(0); {<(B)=(S(0))> /\ <(A)=(A)>}
> let c2 = hoareAssignment C (Var A) (And (PropVar $ Eq (Var B) (S Z)) (PropVar $ Eq (Var C) (Var A)))
{<(B)=(S(0))> /\ <(A)=(A)>} C := A; {<(B)=(S(0))> /\ <(C)=(A)>}
> hoareSequence c1 c2
Right {<(S(0))=(S(0))> /\ <(A)=(A)>} B := S(0); C := A; {<(B)=(S(0))> /\ <(C)=(A)>}
\end{lstlisting}

\subsubsection{H-Conditional}

We provide an implementation for the Hoare conditional rule.

\begin{lstlisting}
hoareConditional :: Eq a => HoareTriple a -> HoareTriple a -> Either String (HoareTriple a)
hoareConditional (HoareTriple (And b1 p1) c1 q1) (HoareTriple (And (Not b2) p2) c2 q2)
  | b1 == b2 && p1 == p2 && q1 == q2  = Right $ HoareTriple p1 (CIfElse b1 c1 c2) q1
hoareConditional (HoareTriple (And p1 b1) c1 q1) (HoareTriple (And (Not p2) b2) c2 q2)
  | b1 == b2 && p1 == p2 && q1 == q2  = Right $ HoareTriple p1 (CIfElse b1 c1 c2) q1
hoareConditional _ _ = Left "hoareConditional: Cannot construct proof"
\end{lstlisting}

For the purposes of example, we start by considering the command:

\begin{lstlisting}
> CIfElse (Not (PropVar $ Eq (Var A) Z)) CSkip (CAssign A (Plus (Var A) (S Z)))
(If (~(A)=(0)) Then (;) Else (A := (A)+(S(0));));
\end{lstlisting}

Following the rule to construct a Hoare triple for this command, we can notice that the conditionals \texttt{B} and \texttt{P} are given in the code, so we have to construct the two triples $\{A \neq 0 \land P\} \ ; \{Q\}$ and $\{\neg(A \neq 0) \land P\} A := 1 + A; \{Q\}$.

\begin{lstlisting}
> let triple1 = hoareSkip (And (Not $ PropVar (Eq (Var A) Z)) (PropVar $ Eq Z Z))
{<~(A)=(0)> /\ <(0)=(0)>} ; {<~(A)=(0)> /\ <(0)=(0)>}
> let triple2 = hoareAssignment A (S (Var A)) (And (Not $ PropVar (Eq (Var A) Z)) (PropVar $ Eq Z Z))
{<~(S(A))=(0)> /\ <(0)=(0)>} A := S(A); {<~(A)=(0)> /\ <(0)=(0)>}
\end{lstlisting}

The next thing to do is to transform the precondition of the second triple to match the first one.

\begin{lstlisting}
> let prf1 = ruleFantasy (\pq -> ruleJoin (ruleSpec (axiom1 A) A (Var A)) (ruleSepR pq)) (And (PropVar (Eq (Var A) Z)) (PropVar $ Eq Z Z))
|- <<(A)=(0)> /\ <(0)=(0)>> -> <<~(S(A))=(0)> /\ <(0)=(0)>>
> let prf2 = ruleFantasy id $ (And (Not $ PropVar (Eq (Var A) Z)) (PropVar $ Eq Z Z))
|- <<~(A)=(0)> /\ <(0)=(0)>> -> <<~(A)=(0)> /\ <(0)=(0)>>
\end{lstlisting}

Given these two proofs, we can now transform the triple easily, and conclude our proof:

\begin{lstlisting}
> let triple3 = hoareConsequence prf1 triple2 prf2
Right {<(A)=(0)> /\ <(0)=(0)>} A := S(A); {<~(A)=(0)> /\ <(0)=(0)>}
> whenRight triple3 (\triple3 -> hoareConditional triple3 triple1)
Right {(0)=(0)} (If ((A)=(0)) Then (A := S(A);) Else (;)); {<~(A)=(0)> /\ <(0)=(0)>}
\end{lstlisting}

\subsubsection{H-While}

In this part, we provide the implementation of the last and most important and complex rule.

\begin{lstlisting}
hoareWhile :: Eq a => HoareTriple a -> Either String (HoareTriple a)
hoareWhile (HoareTriple (And b p1) c p2)
  | p1 == p2  = Right $ HoareTriple p1 (CWhile b c) (And (Not b) p1)
hoareWhile (HoareTriple (And p1 b) c p2)
  | p1 == p2  = Right $ HoareTriple p1 (CWhile b c) (And (Not b) p1)
hoareWhile _ = Left "hoareWhile: Cannot construct proof"
\end{lstlisting}

The implementation for constructing the rule is straightforward, but the tricky part is that we have to properly construct the precondition and the postcondition so that they match the rule.

\subsection{A complete proof example}

In this section, we will provide a proof for the program \texttt{countToB}, namely that $B$ will be equal to $A$ after its execution.

According to the program definition, we need to apply the rules in order: H-Sequence, H-Assign, H-While.

Looking at the while rule, we can determine the values of \texttt{B} and \texttt{S} based on the command; meanwhile, one valid invariant would be $\exists C: A + C = B$.

\[
\AxiomC{$\{\neg(A = B) \land \exists C: A + C = B\}A\texttt{ := }S(A) \ \{\exists C: A + C = B\}$}
\RightLabel{(step1)}
\UnaryInfC{$\{P\}\texttt{while } \neg(A = B) \texttt{ do }A\texttt{ := }S(A) \ \{\neg (\neg (A = B)) \land \exists C: A + C = B\}$}
\DisplayProof
\]

Further, since this rule has to be followed in sequence with the assignment rule, it dictates the conditions for it:

\[
\AxiomC{}
\RightLabel{(step2)}
\UnaryInfC{$\{\exists C: 0 + C = B\}\texttt{ A := 0 } \{\exists C: A + C = B\}$}
\DisplayProof
\]

The only thing remaining to prove is the hypothesis for the H-While rule, so we have the following code:

\begin{lstlisting}
step1 = whenRight step3 (\step3 -> hoareSequence step2 step3)
step2 = hoareAssignment A Z (PropVar (Exists C (PropVar $ Eq (Plus (Var A) (Var C)) (Var B))))
step3 = whenRight ??? hoareWhile
\end{lstlisting}

To start with, we consider the following code:

\begin{lstlisting}
> let step5 = hoareAssignment A (S (Var A)) (PropVar (Exists C (PropVar $ Eq (Plus (Var A) (Var C)) (Var B))))
{Exists C:((S(A))+(C))=(B)} A := S(A); {Exists C:((A)+(C))=(B)}
\end{lstlisting}

The resulting triple is close, but does not exactly match the hypothesis of step1's hypothesis, more specifically the precondition. We will apply the H-Consequence rule, and to do that, we need to provide a proof for the statement:
$$\neg (A = B) \land \exists C: A + C = B \to \exists C: S(A) + C = B$$

We now have the following:

\begin{lstlisting}
preConseq  = ???
postConseq = ruleFantasy id (PropVar (Exists C (PropVar $ Eq (Plus (Var A) (Var C)) (Var B))))
step4 = hoareConsequence preConseq step5 postConseq
\end{lstlisting}

Here's the complete proof for the preconditional part:

\begin{lstlisting}
preConseq =
  let premise = And (Not (PropVar $ Eq (Var A) (Var B))) (PropVar (Exists C (PropVar $ Eq (Plus (Var A) (Var C)) (Var B))))
      f premise =
       -- |- ~~Exists C:((A)+(C))=(B)
       let step1 = ruleDoubleTildeIntro (ruleSepR premise)
           -- |- ~~((A)+(S(C)))=(B)
           step2 = applyFOLRule [GoLeft] (\x -> ruleSpec (ruleInterchangeR x) C (S (Var C))) step1
           -- |- ((A)+(S(C)))=(B)
           step3 = ruleDoubleTildeElim step2
           -- |- ((A)+(S(C)))=((S(A))+(C))
           step4 = ruleSpec (ruleSpec theorem1 C (Var C)) D (Var A)
           -- |- ((S(A))+(C))=((A)+(S(C)))
           step5 = ruleSymmetry step4
           -- |- ((S(A))+(C))=(B)
           step6 = ruleTransitivity step5 step3
           -- |- Exists C:((S(A))+(C))=(B)
           in ruleExistence step6 C []
     -- |- <<~(A)=(B)> /\ <Exists C:((A)+(C))=(B)>> -> <Exists C:((S(A))+(C))=(B)>
     in ruleFantasy f premise
\end{lstlisting}

Finally, \texttt{step1} produces the triple:
$$\{\exists C: 0+C=B\} A \texttt{ := } 0 \texttt{; while } \neg(A = B) \texttt{ do }A\texttt{ := }S(A) \ \{\neg (\neg (A = B)) \land \exists C: A + C = B\}$$

\section{Conclusion and future work}

Compile-time, run-time, etc. are all about having evaluations at different levels. There is still computation going on, but the computation strategies at the compile-time level may be different from those at the run-time level. A full evaluation of \texttt{Command} can be expensive, and sometimes even not terminate, and we wanted a way to deduce propositions without doing a full evaluation. We achieved this by providing an implementation of Hoare logic.

The biggest disadvantage of the provided implementation is that we had to manually construct the proofs, which is a bit tedious; it feels like working with assembly/machine code. Ideally, we would rely on an automated theorem prover that would derive the necessary formulas automatically. Further, the underlying number-theoretical system uses Peano's axioms which are limited to natural numbers - we could extend it to integers for better expressibility. Lastly, we could increase the expressiveness of the logical system by allowing additional definitions to be incorporated.

Even though the mathematical formulas for these systems look simple, implementing them is a different matter. Looking at the implementation, we see how complex these systems can get. Nevertheless, this introductory paper may serve as a good starting point toward building systems of similar nature.

\section{Conflict of interest}

The author declares that they have no conflict of interest.

\begin{thebibliography}{1}

\bibitem{b1}
Rustan M. Leino
\newblock Dafny: An automatic program verifier for functional correctness
\newblock {\em International Conference on Logic for Programming Artificial Intelligence and Reasoning, pp. 348-370. Springer, Berlin, Heidelberg}, 2010.

\bibitem{b2}
Leonardo De Moura, Nikolaj Bjørner
\newblock Z3: An efficient SMT solver.
\newblock {\em International conference on Tools and Algorithms for the Construction and Analysis of Systems. Springer, Berlin, Heidelberg}, 2008.

\bibitem{b3}
Benjamin C. Pierce, Arthur Azevedo de Amorim, Chris Casinghino, Marco Gaboardi, Michael Greenberg, Cătălin Hriţcu, Vilhelm Sjöberg, Brent Yorgey
\newblock Logical Foundations
\newblock {\em Electronic textbook}, 2020.

\bibitem{b4}
Bruno Barras, Samuel Boutin, Cristina Cornes, Judicaël Courant, Jean-Christophe Filliâtre, et al.
\newblock The Coq Proof Assistant Reference Manual: Version 6.1
\newblock {\em [Research Report] RT-0203, INRIA}, 1997.

\bibitem{b5}
Boro Sitnikovski
\newblock Gentle Introduction to Dependent Types with Idris
\newblock {\em Leanpub/Amazon KDP}, 2018.

\bibitem{b6}
Miran Lipovaca
\newblock Learn You a Haskell For Great Good
\newblock {\em No Starch Press}, 2011.

\bibitem{b7}
Douglas Hofstadter
\newblock Godel, Escher, Bach: an Eternal Golden Braid
\newblock {\em Basic Books, Inc.}, 1979.

\bibitem{b8}
Charles A.R. Hoare
\newblock An axiomatic basis for computer programming
\newblock {\em Communications of the ACM, 12(10), pp.576-580}, 1969.

\end{thebibliography}

\end{document}
