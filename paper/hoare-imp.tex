\documentclass{article}

\usepackage{arxiv}
\usepackage{bussproofs}
\usepackage{amsmath}
\usepackage{amsthm}
\usepackage{color}
\usepackage{xcolor}
\usepackage{listings}

\theoremstyle{definition}
\newtheorem{definition}{Definition}[section]
\newtheorem{example}{Example}[section]

\definecolor{dkgreen}{rgb}{0,0.6,0}
\definecolor{gray}{rgb}{0.5,0.5,0.5}
\definecolor{mauve}{rgb}{0.58,0,0.82}

\lstset{frame=tb,
  language=Haskell,
  aboveskip=3mm,
  belowskip=3mm,
  showstringspaces=false,
  columns=flexible,
  basicstyle={\small\ttfamily},
  numbers=none,
  numberstyle=\tiny\color{gray},
  keywordstyle=\color{blue},
  commentstyle=\color{dkgreen},
  stringstyle=\color{mauve},
  breaklines=true,
  breakatwhitespace=true,
  frame=none,
  tabsize=3
}

\newcommand{\matr}[1]{\mathbf{#1}}

\title{Tutorial on implementing Hoare logic for imperative programs in Haskell}

\author{
  Boro Sitnikovski \\
  Skopje, North Macedonia \\
  \texttt{buritomath@gmail.com} \\
}

\begin{document}
\maketitle

\begin{abstract}
Using the programming language Haskell, we introduce an implementation for a simple imperative language that can evaluate arithmetic and boolean expressions; step by step, we will expand the implementation starting from arithmetic expressions, to boolean expressions and then to imperative programs. As we expand the language, we will show several evaluation strategies, considering the normalization property and how it affects an implementation. Finally, we will provide a bottom-up implementation of Hoare's logic which will allow us to deduce facts about programs without the need for a full evaluation.
\end{abstract}

\keywords{Imperative languages \and Functional languages \and Hoare logic \and Formal verification \and Haskell}

\section{Introduction}

Nowadays, imperative programming languages run the world, to list a few popular ones: C, Python, JavaScript, PHP. Code is usually written in these languages by using an imperative style; that is, the computer is being told ("commanded") what to do and how to do it specifically. The mathematical language is very unlike this, it is more declarative rather than imperative, that is, it doesn't care about the how.

Since a programmer has to specify the exact "how", it is easy to make a programming error. In addition, given the popularity of these programming languages, there are many bugs in software applications that are programmed in them. This motivates for a way to formally verify certain properties about programs written in these languages. Hoare logic is one way to mechanically reason about computer programs.

We will provide an implementation of an imperative language together with a toy implementation of Hoare logic that will allow us to reason about programs in this language. Our implementation of Hoare's logic will be bottom-up, in the sense that we will build the proofs from the ground up, in contrast to e.g. programming languages such as Dafny\cite{b1}, that build proofs from top to bottom. That is, in Dafny, the user provides a proposition and Dafny will derive the proof, automatically, using the automated theorem prover Z3\cite{b2}.

The programming language that we will implement already has an implementation in Coq\cite{b3}. However, implementing a language in Haskell is more concerned about playing at the value level (and to some extent at the type level), whereas in a dependently-typed language the focus is at the type level. Specifically for Hoare's logic, in Haskell we cannot use any of the meta language's constructs to do mathematical proofs, so we have to take care of these algorithms ourselves.

Haskell is not a strongly normalizing language, which means that not every evaluation necessarily terminates. However, in dependently-typed languages, such as Coq\cite{b4}, the evaluation of proof terms (e.g. the type checker) is strongly normalizing, and this is what allows us to express mathematical proofs.

There are good introductory books on dependent types\cite{b3}. In some books, there is a gentler approach which might be handy for newcomers\cite{b5}. There are good introductions to Haskell as well\cite{b6}.

\section{Numbers language}

We provide the syntax, evaluation rules, and the implementation in Haskell of a simple language that is strongly normalizing.

\subsection{Arithmetic}

We start by introducing a language that can do arithmetic. The syntax of the language expressed in BNF (Backus-Naur Form) is as follows:

\begin{lstlisting}
digit  ::= "0" | "1" | ... | "8" | "9"
aexp   ::= aterm | aterm relop aterm
number ::= - digit* | digit*
relop  ::= "+" | "-" | "*"
aterm  ::= aexp | number | var
var    ::= A | B | C ... | Y | Z
\end{lstlisting}

Followed by a direct translation to Haskell code:

\begin{lstlisting}
data Aexp =
  ANum Integer
  | AId Char
  | APlus Aexp Aexp
  | AMinus Aexp Aexp
  | AMult Aexp Aexp
\end{lstlisting}

We show the evaluation rules for optimizing an expression. In this context, "optimization" is just another evaluation strategy.

\[
\AxiomC{}
\RightLabel{(A-Opt-Plus)}
\UnaryInfC{$\texttt{APlus} \ \$a_1 \ \$a_2 \hookrightarrow \$(a_1 + a_2)$}
\DisplayProof
\quad
\AxiomC{}
\RightLabel{(A-Opt-Minus)}
\UnaryInfC{$\texttt{AMinus} \ \$a_1 \ \$a_2 \hookrightarrow \$(a_1 - a_2)$}
\DisplayProof
\quad
\]
\hfill
\[
\AxiomC{}
\RightLabel{(A-Opt-Mult)}
\UnaryInfC{$\texttt{AMult} \ \$a_1 \ \$a_2 \hookrightarrow \$(a_1 \cdot a_2)$}
\DisplayProof
\]

That is, we lift the values from our language to the meta language (Haskell), where the symbol $\$$ represents the value constructor \texttt{ANum}, and the symbol $\hookrightarrow$ represents the optimization function.

The same rules represented in Haskell:

\begin{lstlisting}
aoptimize :: Aexp -> Aexp
aoptimize (APlus (ANum a1) (ANum a2)) = ANum (a1 + a2)
aoptimize (AMinus (ANum a1) (ANum a2)) = ANum (a1 - a2)
aoptimize (AMult (ANum a1) (ANum a2)) = ANum (a1 * a2)
aoptimize x = x
\end{lstlisting}

\subsection{Boolean}

Next, we introduce a language that can handle boolean expressions. The syntax of the language expressed in BNF is:

\begin{lstlisting}
bexp   ::= bterm | bterm brelop bterm | aterm arelop aterm | unop bterm
arelop ::= "==" | "<"
brelop ::= "&&"
bterm  ::= "T" | "F"
unop   ::= "!"
\end{lstlisting}

The same syntax is represented with Haskell code:

\begin{lstlisting}
data Bexp =
  BTrue
  | BFalse
  | BEq Aexp Aexp
  | BLe Aexp Aexp
  | BNot Bexp
  | BAnd Bexp Bexp
\end{lstlisting}

Similarly to \texttt{aoptimize}, we list the evaluation rules for optimizing a boolean expression:

\[
\AxiomC{$a_1 = a_2$}
\RightLabel{(B-Eq-Num-True)}
\UnaryInfC{$\texttt{BEq} \ \$a_1 \ \$a_2 \hookrightarrow \texttt{BTrue}$}
\DisplayProof
\quad
\AxiomC{$a_1 \neq a_2$}
\RightLabel{(B-Eq-Num-False)}
\UnaryInfC{$\texttt{BEq} \ \$a_1 \ \$a_2 \hookrightarrow \texttt{BFalse}$}
\DisplayProof
\]
\hfill
\[
\AxiomC{$v_1 = v_2$}
\RightLabel{(B-Eq-Id-True)}
\UnaryInfC{$\texttt{BEq} \ \#v_1 \ \#v_2 \hookrightarrow \texttt{BTrue}$}
\DisplayProof
\quad
\AxiomC{$v_1 \neq v_2$}
\RightLabel{(B-Eq-Id-False)}
\UnaryInfC{$\texttt{BEq} \ \#v_1 \ \#v_2 \hookrightarrow \texttt{BEq} \ \#v_1 \ \#v_2$}
\DisplayProof
\]
\hfill
\[
\AxiomC{}
\RightLabel{(B-Neg-True)}
\UnaryInfC{$ \texttt{BNot} \ \texttt{BTrue} \hookrightarrow \texttt{BFalse}$}
\DisplayProof
\quad
\AxiomC{}
\RightLabel{(B-Neg-False)}
\UnaryInfC{$ \texttt{BNot} \ \texttt{BFalse} \hookrightarrow \texttt{BTrue}$}
\DisplayProof
\]
\hfill
\[
\AxiomC{}
\RightLabel{(B-And-False)}
\UnaryInfC{$ \texttt{BAnd BFalse} \ x \hookrightarrow \texttt{BFalse} $}
\DisplayProof
\quad
\AxiomC{}
\RightLabel{(B-And-True)}
\UnaryInfC{$ \texttt{BAnd BTrue} \ x \hookrightarrow x $}
\DisplayProof
\]

Where the $\#$ symbol represents a variable (the value constructor \texttt{AId}).

These rules translate to the following implementation in Haskell:

\begin{lstlisting}
boptimize :: Bexp -> Bexp
boptimize (BEq (ANum a1) (ANum a2)) = if a1 == a2 then BTrue else BFalse
boptimize (BEq (AId v1) (AId v2)) = if v1 == v2 then BTrue else BEq (AId v1) (AId v2)
boptimize (BNot BTrue) = BFalse
boptimize (BNot BFalse) = BTrue
boptimize (BAnd BFalse _) = BFalse
boptimize (BAnd BTrue b2) = b2
boptimize x = x
\end{lstlisting}

\subsection{Evaluation}

The optimization functions \texttt{aoptimize} and \texttt{boptimize} represent a simple single-step evaluation. Next, we introduce a way to do a full evaluation of arithmetic and boolean expressions.

To support variables, we introduce the notion of a context; one implementation in Haskell is simply a mapping from characters to numbers.

\begin{lstlisting}
type Context = M.Map Char Integer
\end{lstlisting}

We list the evaluation rules for arithmetic expressions:

\[
\AxiomC{$(\#v, \$v') \in ctx$}
\RightLabel{(A-Eval-Id)}
\UnaryInfC{$\#v \underset{ctx}{\to} \$v'$}
\DisplayProof
\quad
\AxiomC{}
\RightLabel{(A-Eval-Num)}
\UnaryInfC{$\$n \underset{ctx}{\to} n$}
\DisplayProof
\quad
\AxiomC{$a_1 \underset{ctx}{\to} a_1' , a_2 \underset{ctx}{\to} a_2'$}
\RightLabel{(A-Eval-Plus)}
\UnaryInfC{$\texttt{APlus} \ a_1 \ a_2 \underset{ctx}{\to} a_1' + a_2'$}
\DisplayProof
\]
\hfill
\[
\AxiomC{$a_1 \underset{ctx}{\to} a_1' , a_2 \underset{ctx}{\to} a_2'$}
\RightLabel{(A-Eval-Minus)}
\UnaryInfC{$\texttt{AMinus} \ a_1 \ a_2 \underset{ctx}{\to} a_1' - a_2'$}
\DisplayProof
\quad
\quad
\AxiomC{$a_1 \underset{ctx}{\to} a_1' , a_2 \underset{ctx}{\to} a_2'$}
\RightLabel{(A-Eval-Mult)}
\UnaryInfC{$\texttt{AMult} \ a_1 \ a_2 \underset{ctx}{\to} a_1' \cdot a_2'$}
\DisplayProof
\]

The arrow symbol $\underset{ctx}{\to}$ in the rules represents the actual evaluation of arithmetic expressions under context $ctx$.

Follows the implementation of these rules in Haskell:

\begin{lstlisting}
aeval :: Context -> Aexp -> Integer
aeval ctx (AId v) = ctx M.! v -- element may not exist
aeval ctx (ANum n) = n
aeval ctx (APlus a1 a2) = aeval ctx a1 + aeval ctx a2
aeval ctx (AMinus a1 a2) = aeval ctx a1 - aeval ctx a2
aeval ctx (AMult a1 a2) = aeval ctx a1 * aeval ctx a2
\end{lstlisting}

Finally, the evaluation rules for boolean expressions:

\[
\AxiomC{}
\RightLabel{(B-Eval-True)}
\UnaryInfC{$\texttt{BTrue} \underset{ctx}{\Rightarrow} \texttt{True}$}
\DisplayProof
\quad
\AxiomC{}
\RightLabel{(B-Eval-False)}
\UnaryInfC{$\texttt{BFalse} \underset{ctx}{\Rightarrow} \texttt{False}$}
\DisplayProof
\]
\hfill
\[
\AxiomC{$a_1 \underset{ctx}{\to} a_1' , a_2 \underset{ctx}{\to} a_2'$}
\RightLabel{(B-Eval-Eq)}
\UnaryInfC{$\texttt{BEq} \ a_1 \ a_2 \underset{ctx}{\Rightarrow} a_1' = a_2'$}
\DisplayProof
\quad
\AxiomC{$a_1 \underset{ctx}{\to} a_1' , a_2 \underset{ctx}{\to} a_2'$}
\RightLabel{(B-Eval-Le)}
\UnaryInfC{$\texttt{BLe} \ a_1 \ a_2 \underset{ctx}{\Rightarrow} a_1' \le a_2'$}
\DisplayProof
\]
\hfill
\[
\AxiomC{$b \underset{ctx}{\Rightarrow} b'$}
\RightLabel{(B-Eval-Not)}
\UnaryInfC{$\texttt{BNot} \ b' \underset{ctx}{\Rightarrow} \neg b'$}
\DisplayProof
\quad
\AxiomC{$b_1 \underset{ctx}{\Rightarrow} b_1' , b_2 \underset{ctx}{\Rightarrow} b_2'$}
\RightLabel{(B-Eval-And)}
\UnaryInfC{$\texttt{BAnd} \ b_1 \ b_2 \underset{ctx}{\Rightarrow} b_1' \land b_2'$}
\DisplayProof
\]

Similarly, the double right arrow symbol $\underset{ctx}{\Rightarrow}$ in the rules represents the actual evaluation of boolean expressions under context $ctx$.

We provide the implementation of these rules in Haskell:

\begin{lstlisting}
beval :: Context -> Bexp -> Bool
beval ctx BTrue = True
beval ctx BFalse = False
beval ctx (BEq a1 a2) = aeval ctx a1 == aeval ctx a2
beval ctx (BLe a1 a2) = aeval ctx a1 <= aeval ctx a2
beval ctx (BNot b1) = not (beval ctx b1)
beval ctx (BAnd b1 b2) = beval ctx b1 && beval ctx b2
\end{lstlisting}

For example, the single-step optimization values can be used as following:

\begin{lstlisting}
> let expr = BNot BTrue in "Optimize: " ++ show expr ++ " = " ++ show (boptimize expr)
Optimize: ! (TRUE) = FALSE

> let expr = APlus (ANum 2) (ANum 5) in "Optimize: " ++ show expr ++ " = " ++ show (aoptimize expr)
Optimize: 2 + 5 = 7
\end{lstlisting}

However, since the single-step evaluation strategy does not rely on any context, it will not be able to deduce much about expressions that involve variables, e.g. \texttt{X + 5}, while \texttt{aeval} can substitute for this variable, given a context:

\begin{lstlisting}
> let expr = APlus (AId 'X') (ANum 5) in "Optimize: " ++ show expr ++ " = " ++ show (aoptimize expr)
Optimize: X + 5 = X + 5

> let expr = APlus (AId 'X') (ANum 5) in show expr ++ " = " ++ show (aeval (M.fromList [('X', 5)]) expr)
X + 5 = 10

> let expr = BEq (AId 'X') (ANum 5) in show expr ++ " = " ++ show (beval (M.fromList [('X', 5)]) expr)
X == 5 = True
\end{lstlisting}

\section{Imperative language}

We proceed with providing the syntax, evaluation rules, and the implementation in Haskell of an imperative language.

\subsection{Commands}

We show the data type of the imperative language expressed in Haskell:

\begin{lstlisting}
data Command =
  CSkip
  | CAssign Char Aexp
  | CSequence Command Command
  | CIfElse Bexp Command Command
  | CWhile Bexp Command
  | CAssert Bexp Command Bexp
\end{lstlisting}

That is, the language contains the minimum set of commands which make an imperative language:

\begin{itemize}
\item \texttt{CSkip} is the the no operation command - the empty statement.
\item \texttt{CAssign} will assign a value to a variable in a context.
\item \texttt{CSequence} will join two commands, which allows for the evaluation of commands in sequence.
\item \texttt{CIfElse} accepts a boolean and depending on its value either executes one command, or another.
\item \texttt{CWhile} accepts a boolean and keeps executing a command as long as the boolean is true.
\item \texttt{CAssert} accepts a precondition, a command, and a postcondition. The evaluation will be successful if the precondition is satisfied before executing the command, and the postcondition is satisfied after executing the command.
\end{itemize}

We show the evaluation rules for this language:

\[
\AxiomC{}
\RightLabel{(C-Eval-Skip)}
\UnaryInfC{$\texttt{CSkip} \underset{ctx}{\mapsto} ctx$}
\DisplayProof
\]
\hfill
\[
\AxiomC{$v \underset{ctx}{\to} v'$}
\RightLabel{(C-Eval-Assign)}
\UnaryInfC{$\texttt{CAssign} \ c \ v \underset{ctx}{\mapsto} ctx \cup (c, v')$}
\DisplayProof
\quad
\AxiomC{$c_1 \underset{ctx}{\mapsto} ctx', c_2 \underset{ctx'}{\mapsto} ctx''$}
\RightLabel{(C-Eval-Sequence)}
\UnaryInfC{$\texttt{CSequence} \ c_1 \ c_2 \underset{ctx}{\mapsto} ctx''$}
\DisplayProof
\]
\hfill
\[
\AxiomC{$b \underset{ctx}{\Rightarrow} \texttt{True}, c_1 \underset{ctx}{\mapsto} ctx'$}
\RightLabel{(C-Eval-IfTrue)}
\UnaryInfC{$\texttt{CIfElse} \ b \ c_1 \ c_2 \underset{ctx}{\mapsto} ctx'$}
\DisplayProof
\quad
\AxiomC{$b \underset{ctx}{\Rightarrow} \texttt{False}, c_2 \underset{ctx}{\mapsto} ctx'$}
\RightLabel{(C-Eval-IfFalse)}
\UnaryInfC{$\texttt{CIfElse} \ b \ c_1 \ c_2 \underset{ctx}{\mapsto} ctx'$}
\DisplayProof
\]
\hfill
\[
\AxiomC{$b \underset{ctx}{\Rightarrow} \texttt{True}, c \underset{ctx}{\mapsto} ctx', \texttt{CWhile} \ b \ c \underset{ctx'}{\mapsto} ctx''$}
\RightLabel{(C-Eval-WhileTrue)}
\UnaryInfC{$\texttt{CWhile} \ b \ c \underset{ctx}{\mapsto} ctx''$}
\DisplayProof
\quad
\AxiomC{$b \underset{ctx}{\Rightarrow} \texttt{False}$}
\RightLabel{(C-Eval-WhileFalse)}
\UnaryInfC{$\texttt{CWhile} \ b \ c \underset{ctx}{\mapsto} ctx$}
\DisplayProof
\]
\hfill
\[
\AxiomC{$b_1 \underset{ctx}{\Rightarrow} \texttt{True}, c \underset{ctx}{\mapsto} ctx', b_2 \underset{ctx'}{\Rightarrow} \texttt{True}$}
\RightLabel{(C-Eval-Assert)}
\UnaryInfC{$\texttt{CAssert} \ b_1 \ c \ b_2$}
\DisplayProof
\]

The map arrow symbol $\underset{ctx}{\mapsto}$ in the rules represents the actual evaluation of a command under context $ctx$.

In Coq, each implementation of the rules would be represented at the type level. However, since we're working at the value level in Haskell, we will rely on the \texttt{Either} data type to distinguish between provable and not provable terms.

\begin{lstlisting}
eval :: Context -> Command -> Either String Context
eval ctx CSkip = Right ctx
eval ctx (CAssign c v) = Right $ M.insert c (aeval ctx v) ctx
eval ctx (CSequence c1 c2) = let ctx' = eval ctx c1 in whenRight ctx' (\ctx'' -> eval ctx'' c2)
eval ctx (CIfElse b c1 c2) = eval ctx $ if beval ctx b then c1 else c2
eval ctx (CWhile b c) =
  if beval ctx b
  then let ctx' = eval ctx c in whenRight ctx' (\ctx'' -> eval ctx'' (CWhile b c))
  else Right ctx
eval ctx (CAssert b1 c b2) =
  if beval ctx b1
  then whenRight (eval ctx c)
       (\ctx' -> if beval ctx' b2
                  then Right ctx'
                  else Left "Post-condition does not match!")
  else Left "Pre-condition does not match!"
\end{lstlisting}

Note that this language is not strongly normalizing because of \texttt{CWhile}; consider the evaluation of \texttt{CWhile BTrue CSkip}.

As an example, the factorial program (sequence of commands) can be represented with the pseudo-code:

\begin{lstlisting}
Z := X
Y := 1
while (~Z = 0)
  Y := Y * Z
  Z := Z - 1
\end{lstlisting}

That is, this program will calculate \texttt{Y := X!}. Here's an implementation of it in our language:

\begin{lstlisting}
> :{
| fact_X =
|   let l1 = CAssign 'Z' (AId 'X')
|       l2 = CAssign 'Y' (ANum 1)
|       l3 = CWhile (BNot (BEq (AId 'Z') (ANum 0))) (CSequence l4 l5)
|       l4 = CAssign 'Y' (AMult (AId 'Y') (AId 'Z'))
|       l5 = CAssign 'Z' (AMinus (AId 'Z') (ANum 1))
|   in CSequence l1 (CSequence l2 l3)
| :}

> eval (M.fromList [('X', 5)]) fact_X
fromList [('X',5),('Y',120),('Z',0)]

> let expr = CAssert (BEq (ANum 5) (AId 'X')) factX (BEq (ANum 120) (AId 'Y')) in "Assert {X=5} factX {Y=120}: " ++ show (eval (M.fromList [('X', 5)]) expr)
Assert {X=5} factX {Y=120}: Right (fromList [('X',5),('Y',120),('Z',0)])

> let expr = CAssert (BEq (ANum 4) (AId 'X')) factX (BEq (ANum 120) (AId 'Y')) in "Assert {X=4} factX {Y=120}: " ++ show (eval (M.fromList [('X', 5)]) expr)
Assert {X=4} factX {Y=120}: Left "Pre-condition does not match!"
\end{lstlisting}

\section{Hoare logic}

In the previous chapter, we implemented assertions (\texttt{CAssert}) at the run-time (\texttt{eval}) level. The biggest disadvantage of that is we have to do a full evaluation to deduce some facts about programs; considering the assertion example of the \texttt{factX} program, it has to actually evaluate the factorial to conclude something. This motivates the need for an additional evaluation strategy that will allow us to deduce facts about programs without doing a full evaluation.

Some programming languages, like Python, don't have a compile step and the \texttt{eval} function we provided is kind of equivalent to evaluating programs in Python. But some programming languages do have a compile step, like C or Haskell, and this compilation step can be beneficial in that it can do additional different checks, e.g., type checks. That's what we'll do here - implement a "compile"-time check (just another evaluation strategy) using some of the rules in Hoare's logic, and this check can be used to check the validity of a program, before fully evaluating it.

We list the rules of Hoare logic, as outlined in the original paper\cite{b7}.

\[
\AxiomC{}
\RightLabel{(H-Skip)}
\UnaryInfC{$\{P\}\texttt{skip}\{P\}$}
\DisplayProof
\quad
\AxiomC{}
\RightLabel{(H-Assign)}
\UnaryInfC{$\{P[E/x]\}x:=E\{P\}$}
\DisplayProof
\quad
\AxiomC{$\{P\}S\{Q\} , \{Q\}T\{R\}$}
\RightLabel{(H-Sequence)}
\UnaryInfC{$\{P\}S;T\{R\}$}
\DisplayProof
\]
\hfill
\[
\AxiomC{$\{B \land P\}S\{Q\} , \{\neg B \land P\}T\{Q\}$}
\RightLabel{(H-Conditional)}
\UnaryInfC{$\{P\}\texttt{if }B\texttt{ then }S\texttt{ else } T\{Q\}$}
\DisplayProof
\quad
\quad
\AxiomC{$\{B \land P\}S\{P\}$}
\RightLabel{(H-While)}
\UnaryInfC{$\{P\}\texttt{while }B\texttt{ do }S\{\neg B \land P\}$}
\DisplayProof
\]

\subsection{Implementation}

We represent the Hoare triple as a product of a command, a precondition (\texttt{Bexp}) and a postcondition (\texttt{Bexp}). In this case, the design decision is that pre/postconditions will be in the language of \texttt{Bexp}, but they can also be in a different language (regardless of that \texttt{Bexp} is used in \texttt{Command}).

\begin{lstlisting}
data HoareTriple = HoareTriple Bexp Command Bexp
\end{lstlisting}

\subsubsection{H-Skip}

We will provide the Haskell implementation of the Hoare skip rule; more specifically, this rule can only be constructed for the \texttt{CSkip} command.

\begin{lstlisting}
hoareSkip :: Command -> Bexp -> Either String HoareTriple
hoareSkip CSkip q = Right $ HoareTriple q CSkip q
hoareSkip _ _ = Left "Cannot construct proof"
\end{lstlisting}

As with \texttt{eval}, the \texttt{Either} data type is used to distinguish between provable and not provable terms:

\begin{lstlisting}
> hoareSkip CSkip (BEq (ANum 3) (ANum 3))
Right {3 == 3} ; {3 == 3}

> hoareSkip (CAssign 'X' (ANum 2)) (BEq (ANum 3) (ANum 3))
Left "Cannot construct proof"
\end{lstlisting}

\subsubsection{H-Assign}

Let \texttt{Q[E/V]} denote the expression \texttt{Q} in which each free occurrence of \texttt{V} is replaced with \texttt{E}. Given an assignment command \texttt{V := E}, it should produce the triple where the precondition is \texttt{Q[E/V]} and the postcondition is \texttt{Q}, for any \texttt{Q}.

\begin{lstlisting}
hoareAssignment :: Command -> Bexp -> Either String HoareTriple
hoareAssignment (CAssign v e) q = Right $ HoareTriple (substAssignment (boptimize q) (aoptimize e) v) (CAssign v e) q
hoareAssginment _ _ = Left "Cannot construct proof"
\end{lstlisting}

We rely on the optimizing functions to further simplify calculations.

There are several ways how the function \texttt{substAssignment} can be implemented. We list a few:

\begin{itemize}
\item One way is to do a full \texttt{Aexp}/\texttt{Bexp} evaluation; we can do this, since these languages are strongly normalizing, compared to our imperative language. However, this evaluation can still take some time, and it requires a context in addition.
\item Another way is to specify some concrete set of mathematical rewrites that can be applied, based on the original languages (\texttt{Aexp}/\texttt{Bexp}).
\end{itemize}

In this paper, the substitution will contain a concrete set of mathematical rewrites, though the reader is encouraged to try different implementations and spot the advantages and disadvantages of each.

\begin{lstlisting}
substAssignment :: Bexp -> Aexp -> Char -> Bexp
substAssignment q@(BEq (AId x) y) e v
  | x == v = BEq e y
  | otherwise = q
substAssignment q@(BEq x (AId y)) e v
  | y == v = BEq e (AId y)
  | otherwise = q
substAssignment (BAnd b1 b2) e v = BAnd (substAssignment b1 e v) (substAssignment b2 e v)
substAssignment (BNot b) e v = BNot (substAssignment b e v)
substAssignment q _ _ = q
\end{lstlisting}

In this case, the implementation will do a rewrite when either the expression on the left or the expression on the right represents a variable. Given this definition, some proofs can be deduced, such as:

\begin{lstlisting}
> hoareAssignment (CAssign 'X' (ANum 3)) (BEq (AId 'X') (ANum 3))
Right {3 == 3} X := 3; {X == 3}
\end{lstlisting}

That is, given the precondition that \texttt{3 = 3}, the assignment \texttt{X := 3} implies the postcondition \texttt{X = 3}. Note that the validity of the precondition is not being checked (since that would require evaluating \texttt{Aexp}/\texttt{Bexp}); the proof merely states that assuming some precondition, a command produces some postcondition.

\subsubsection{H-Sequence}

For the Hoare sequence rule, given two Hoare triples, the postcondition of the first triple must be equivalent to the precondition of the second triple (for some definition of equivalent). We avoid full evaluation and rely on \texttt{boptimize}.

\begin{lstlisting}
hoareSequence :: HoareTriple -> HoareTriple -> Either String HoareTriple
hoareSequence (HoareTriple p c1 q1) (HoareTriple q2 c2 r)
  | boptimize q1 == boptimize q2 = Right $ HoareTriple p (CSequence c1 c2) r
  | otherwise = Left "Cannot construct proof"
\end{lstlisting}

Several commands can be chained as follows:

\begin{lstlisting}
> let c1 = hoareAssignment (CAssign 'Y' (ANum 1)) (BAnd (BEq (AId 'Y') (ANum 1)) (BEq (AId 'X') (AId 'X')))
> let c2 = hoareAssignment (CAssign 'Z' (AId 'X')) (BAnd (BEq (AId 'Y') (ANum 1)) (BEq (AId 'Z') (AId 'X')))
> whenRight c1 (\c1' -> whenRight c2 (\c2' -> hoareSequence c1' c2'))
Right {1 == 1 && X == X} Y := 1;;Z := X;; {Y == 1 && Z == X}
\end{lstlisting}

\subsubsection{H-Conditional}

For the Hoare conditional rule, similarly to the Hoare sequence rule, we rely on \texttt{boptimize} for checking whether the corresponding values match.

\begin{lstlisting}
hoareConditional :: HoareTriple -> HoareTriple -> Either String HoareTriple
hoareConditional (HoareTriple (BAnd b1 p1) c1 q1) (HoareTriple (BAnd (BNot b2) p2) c2 q2)
  | boptimize b1 == boptimize b2 &&
    boptimize p1 == boptimize p2 &&
    boptimize q1 == boptimize q2 = Right $ HoareTriple p1 (CIfElse b1 c1 c2) q1
hoareConditional (HoareTriple (BAnd p1 b1) c1 q1) (HoareTriple (BAnd (BNot p2) b2) c2 q2)
  | boptimize b1 == boptimize b2 &&
    boptimize p1 == boptimize p2 &&
    boptimize q1 == boptimize q2 = Right $ HoareTriple p1 (CIfElse b1 c1 c2) q1
  | otherwise = Left "Cannot construct proof"
hoareConditional _ _ = Left "Cannot construct proof"
\end{lstlisting}

An example usage of the rule:

\begin{lstlisting}
> let b = BEq (AId 'X') (ANum 0)
> let p = BLe (AId 'X') (ANum 10)
> let q = BEq (AId 'X') (ANum 3)
> let c1 = CSequence (CAssign 'X' (ANum 1)) (CAssign 'X' (ANum 3))
> let c2 = CAssign 'X' (ANum 3)
> hoareConditional (HoareTriple (BAnd b p) c1 q) (HoareTriple (BAnd (BNot b) p) c2 q)
Right {X <= 10} (If (X == 0) Then (X := 1;;X := 3;;) Else (X := 3;)); {X == 3}
\end{lstlisting}

\subsubsection{H-While}

Finally, the Hoare while rule accepts triples of the form $\{B \land P\} S \{ P \}$, so we reflect that to the implementation:

\begin{lstlisting}
hoareWhile :: HoareTriple -> Either String HoareTriple
hoareWhile (HoareTriple (BAnd b p1) c p2)
  | p1 == p2 = Right $ HoareTriple p1 (CWhile b c) (BAnd (BNot b) p2)
  | otherwise = Left "Cannot construct proof"
hoareWhile _ = Left "Cannot construct proof"
\end{lstlisting}

We provide an example similar to the previous one, which re-uses \texttt{b}, \texttt{p}, \texttt{q}, \texttt{c2}:

\begin{lstlisting}
> hoareWhile (HoareTriple (BAnd b p) c2 p)
Right {X <= 10} (While (X == 0) Do {X := 3;}); {! (X == 0) && X <= 10}
\end{lstlisting}

\section{Conclusion}
Compile-time, run-time, etc. are all about having evaluations at different levels. There is still computation going on, but e.g. the computation strategies at the compile-time level may be different from those at the run-time level. A full evaluation of \texttt{Command} can be expensive, and sometimes even not terminate, and we wanted a way to deduce propositions without going through all evaluations. We showed how to achieve this, by implementing a subset of Hoare logic as a proof of concept.

The evaluation strategies of a programming language directly affect how a programmer thinks. For example, if a programming language has a type system, the programmer will take advantage of it, subconsciously being aware of the (different) evaluation strategy for the type checker, in addition to the regular evaluation strategy for programs. If a programming language has the feature to verify properties about programs, such as Hoare logic, the programmer will be aware of this different evaluation strategy and use it to write more correct software.

Even though the mathematical formulas for Hoare logic look simple, implementing them is a completely different matter. The implementation details cover stuff like "what expressions do we want to support", "are we working with a strongly normalizing language", "what's the language that will represent propositions", etc. while these details are hidden in the mathematical representation of these formulas.

\begin{thebibliography}{1}

\bibitem{b1}
Rustan M. Leino
\newblock Dafny: An automatic program verifier for functional correctness
\newblock {\em International Conference on Logic for Programming Artificial Intelligence and Reasoning, pp. 348-370. Springer, Berlin, Heidelberg}, 2010.

\bibitem{b2}
Leonardo De Moura, Nikolaj Bjørner
\newblock Z3: An efficient SMT solver.
\newblock {\em International conference on Tools and Algorithms for the Construction and Analysis of Systems. Springer, Berlin, Heidelberg}, 2008.

\bibitem{b3}
Benjamin C. Pierce, Arthur Azevedo de Amorim, Chris Casinghino, Marco Gaboardi, Michael Greenberg, Cătălin Hriţcu, Vilhelm Sjöberg, Brent Yorgey
\newblock Logical Foundations
\newblock {\em Electronic textbook}, 2020.

\bibitem{b4}
Bruno Barras, Samuel Boutin, Cristina Cornes, Judicaël Courant, Jean-Christophe Filliâtre, et al.
\newblock The Coq Proof Assistant Reference Manual: Version 6.1
\newblock {\em [Research Report] RT-0203, INRIA}, 1997.

\bibitem{b5}
Boro Sitnikovski
\newblock Gentle Introduction to Dependent Types with Idris
\newblock {\em Leanpub/Amazon KDP}, 2018.

\bibitem{b6}
Miran Lipovaca
\newblock Learn You a Haskell For Great Good
\newblock {\em No Starch Press}, 2011.

\bibitem{b7}
Charles A.R. Hoare
\newblock An axiomatic basis for computer programming
\newblock {\em Communications of the ACM, 12(10), pp.576-580}, 1969.

\end{thebibliography}

\end{document}
